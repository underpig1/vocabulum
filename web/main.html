<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700;1000&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi" />
    <title>Vocabulum</title>
    <style>
        :root {
            --bg-grid-color: #00000017;
            --tile-size: 45px;
            --tile-color: #f9be74ff;
            --font-color: #333;

            --light-red: #ff6f7bff;
            --light-yellow: #fbd86bff;
            --light-green: #93f46fff;

            touch-action: pan-x pan-y;
            height: 100%;
        }

        html, body {
            width: 100%;
            height: 100%;
            overscroll-behavior-x: none;
            overflow: hidden;
        }

        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            user-select: none;
            touch-action: manipulation;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        body {
            margin: 0;
            user-select: none;
            overflow: hidden;
            position: relative;
        }

        #background {
            width: 100vw;
            height: 100vh;
            margin: 0;
            background-size: var(--tile-size) var(--tile-size);
            background-image: linear-gradient(to right, var(--bg-grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--bg-grid-color) 1px, transparent 1px);
            background-position: 0 0;
        }

        .tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            background-color: var(--tile-color);
            border-radius: calc(var(--tile-size)/5);
            text-align: center;
            line-height: calc(var(--tile-size) + var(--tile-size)/12);
            font-size: calc(var(--tile-size)/1.7);
            font-family: 'Comfortaa', sans-serif;
            font-weight: bold;
            cursor: pointer;
            top: 0;
            left: 0;
            transition: border-radius 0.2s;
            /* transition: transform 0.2s, top 0.1s, left 0.1s; */
        }

        #tile-shadow {
            background-color: #00000055;
            opacity: 0;
            z-index: 2;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .tile:active {
            /* transform: scale(0.85); */
        }

        .tile>.value {
            position: absolute;
            left: calc(var(--tile-size)/7);
            top: calc(var(--tile-size)/7);
            line-height: calc(var(--tile-size)/4);
            font-size: calc(var(--tile-size)/4);
            pointer-events: none;
        }

        #tiles {
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
        }

        .ui {
            position: absolute;
            font-size: 16px;
            line-height: 16px;
            font-size: calc(var(--tile-size)/1.5);
            font-family: 'Comfortaa', sans-serif;
            color: var(--font-color);
            font-weight: bold;
            margin: 0;
            pointer-events: none;
            bottom: 35px;
        }

        .timer {
            right: 35px;
        }

        .score {
            left: 35px;
        }

        .tile[tid="-1"] {
            pointer-events: none;
        }

        .take-2 {
            display: flex;
            width: 100%;
            height: 60px;
            margin-bottom: -15px;
            justify-content: center;
        }

        .take-2>div {
            display: flex;
            width: 85px;
            height: 100%;
            background-color: var(--light-green);
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.1s;
            transform: scale(0.9);
        }

        .take-2 svg {
            fill: white;
            width: 50%;
        }

        .take-2:active div {
            transform: scale(0.85);
        }

        .button {
            width: 90%;
            height: 66px;
            background-color: var(--light-red);
            border-radius: 15px;
            border: solid 5px #333;
            box-shadow: 0px 5px 0px 0px #333;
            font-family: 'Comfortaa', sans-serif;
            font-size: 28px;
            text-align: center;
            line-height: 57px;
            font-weight: 1000;
            color: #333;
            transform: translateY(-5px);
            z-index: 2;
        }

        .buttons {
            z-index: 4;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 230px;
            margin-top: 50%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-direction: column;
        }

        .buttons>.button:active {
            transform: translateY(0);
            box-shadow: 0px 0px 0px 0px #333;
        }

        #overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%;
            right: 0;
            animation: overlay 1s ease-out forwards;
            background-color: black;
            display: block;
            z-index: 6;
        }

        @keyframes overlay {
            0% {
                height: 100%;
            }
            100% {
                height: 0;
                display: none;
            }
        }

        .icon {
            position: absolute;
            top: 35px;
            left: 50px;
            z-index: 5;
        }

        .submit-btn {
            position: absolute;
            bottom: 50px;
            display: flex;
            line-height: 65px;
            flex-direction: row;
            justify-content: center;
            gap: 10px;
            align-items: center;
            left: 50%;
            transform: translate3d(-50%, 0, 0);
            width: calc(100% - 50px);
            max-width: 300px;
            height: 65px;
            font-size: 14pt;
            outline: none;
            border: 4px black solid;
            padding: 0 15px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 600;
            filter: drop-shadow(0 5px 0 black);
            color: black;
            background-color: #93f46fff;
            margin-right: auto;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.1s ease, opacity 0.3s ease;
            z-index: 5;
        }

        .submit-btn:hover {
            transform: translate3d(-50%, 0, 0) scale(0.95);
        }

        .submit-btn.active {
            transform: translate3d(-50%, 0, 0) scale(0.9);
        }

        .submit-btn.hidden {
            opacity: 0;
            transform: translate3d(-50%, 0, 0) scale(0.7) !important;
            pointer-events: none;
        }

        .submit-btn.final-round {
            background-color: #ffdc6f;
        }

        .notify-msg {
            position: absolute;
            top: 35px;
            right: 50px;
            display: flex;
            line-height: 60px;
            flex-direction: row;
            justify-content: center;
            gap: 15px;
            align-items: center;
            width: max-content;
            height: 60px;
            font-size: 12pt;
            outline: none;
            padding: 0 25px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            color: black;
            background-color: #c9c9c9;
            margin-right: auto;
            cursor: pointer;
            border: 4px black solid;
            filter: drop-shadow(0 5px 0 black);
            border-radius: 15px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            z-index: 4;
        }

        .notify-msg * {
            opacity: 0.9;
        }

        .notify-msg.active {
            opacity: 1;
            transform: none;
        }

        .notify-msg div {
            background-color: #dbdbdb;
            display: block;
            position: absolute;
            width: 0;
            left: 0;
            top: 0;
            bottom: 0;
            border-radius: 15px 0 0 15px;
        }

        .notify-msg.active div {
            animation: notify-move 3s linear forwards;
        }

        #timer {
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            font-size: 18pt;
            position: absolute;
            bottom: 50px;
            right: 50px;
            z-index: 5;
        }

        #timer span {
            display: inline-block;
            width: 0.7em;
            text-align: center;
        }

        #score {
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            font-size: 18pt;
            position: absolute;
            bottom: 50px;
            left: 50px;
        }

        .control.hidden {
            opacity: 0 !important;
            pointer-events: none;
        }

        @keyframes notify-move {
            0% {
                width: 0;
            }
            90% {
                width: 90%;
                border-radius: 15px 0 0 15px;
            }
            100% {
                width: 100%;
                border-radius: 15px;
            }
        }

        @keyframes button-click {
            0% {
                transform: scale(1);
            }
        }

        #recenter-btn {
            position: absolute;
            top: 35px;
            right: 50px;
            width: 30px;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.8);
            transition: transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none;
        }

        #recenter-btn.active {
            transform: scale(1);
            opacity: 1;
            pointer-events: all;
        }

        .progress-msg {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate3d(-50%, -50%, 0) scale(0.7) rotate(5deg);
            width: 400px;
            max-width: calc(100% - 100px);
            pointer-events: none;
            opacity: 0;
            z-index: 4;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }

        .progress-msg.active {
            opacity: 1;
            transform: translate3d(-50%, -50%, 0) scale(1) rotate(0);
        }

        .review-header {
            position: absolute;
            left: 50px;
            top: 100px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            font-size: 14pt;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.7);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .review-header.active {
            transform: none;
            opacity: 0.7;
        }

        .board-header {
            position: absolute;
            display: flex;
            left: 50px;
            top: 110px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 700;
            font-size: 32pt;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.7);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .board-header.active {
            transform: none;
            opacity: 1;
        }

        .trophy {
            --rotation: 10deg;
            position: absolute;
            display: none;
            top: 50%;
            transform: translate3d(0, -50%, 0);
            width: 125px;
            margin-left: 50px;
            animation: trophy 2s ease infinite;
        }

        .trophy.active {
            display: block;
        }

        .trophy-branch {
            animation-delay: 0.2s;
        }

        @keyframes trophy {
            0% {
                transform: translate3d(0, -50%, 0) scale(1, 1) rotate(calc(0deg - var(--rotation)));
            }
            50% {
                transform: translate3d(0, -50%, 0) scale(1, 1) rotate(var(--rotation));
            }
            100% {
                transform: translate3d(0, -50%, 0) scale(1, 1) rotate(calc(0deg - var(--rotation)));
            }
        }

        .review-next {
            position: absolute;
            bottom: 50px;
            left: 50px;
            height: 50px;
            opacity: 0;
            transform: scale(0.7);
            transition: transform 0.3s ease, opacity 0.3s ease;
            cursor: pointer;
            pointer-events: none;
        }

        .review-next.active {
            opacity: 1;
            transform: none;
            pointer-events: all;
        }

        .review-next:hover {
            transform: scale(0.9);
        }

        .review-next:active {
            transform: scale(0.8);
        }

        .review-next.classic {
            left: 50%;
            transform: translate3d(-50%, 0, 0) scale(0.7);
        }

        .review-next.classic.active {
            transform: translate3d(-50%, 0, 0);
        }

        .review-next.classic:hover {
            transform: translate3d(-50%, 0, 0) scale(0.9);
        }

        .review-next.classic:active {
            transform: translate3d(-50%, 0, 0) scale(0.8);
        }

        #review-score {
            position: absolute;
            top: 110px;
            right: 50px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 700;
            font-weight: 500;
            font-size: 32pt;
            opacity: 0;
            transform: scale(0.7);
            transition: transform 0.3s ease, opacity 0.3s ease;
            transition-delay: 0.1s;
        }

        #review-score.active {
            transform: none;
            opacity: 1;
        }

        @media only screen and (max-width: 900px) {
            .icon {
                top: 25px;
                left: 50%;
                transform: translate3d(-50%, 0, 0);
            }

            .notify-msg {
                left: 50%;
                top: 75px;
                font-size: 11pt;
                transform: translate3d(-50%, 0, 0) scale(0.8);
            }

            .notify-msg.active {
                transform: translate3d(-50%, 0, 0);
            }

            .submit-btn {
                bottom: 30px;
                font-size: 11pt;
                height: 60px;
                width: calc(100% - 250px);
            }

            #score {
                bottom: 25px;
                left: 25px;
                width: 75px;
                text-align: center;
            }

            #timer {
                bottom: 25px;
                right: 25px;
            }

            #recenter-btn {
                right: 25px;
                top: 30px;
            }

            .board-header {
                left: 0;
                right: 0;
                top: 125px;
                text-align: center;
                font-size: 18pt;
                justify-content: center;
            }

            .trophy {
                margin-left: 15px;
                width: 50px;
            }

            .review-header {
                left: 0;
                right: 0;
                top: 100px;
                text-align: center;
                font-size: 12pt;
            }

            #review-score {
                left: 0;
                right: 0;
                top: 165px;
                text-align: center;
                font-size: 24pt;
            }

            .review-next {
                left: 50%;
                transform: translate3d(-50%, 0, 0) scale(0.7);
            }

            .review-next.active {
                transform: translate3d(-50%, 0, 0) !important;
            }

            .review-next:hover {
                transform: translate3d(-50%, 0, 0) scale(0.9);
            }

            .review-next:active {
                transform: translate3d(-50%, 0, 0) scale(0.8);
            }
        }

        @media only screen and (max-width: 400px) {
            .submit-btn {
                width: calc(100% - 200px);
            }
        }
    </style>
</head>

<body>
    <div id="background"></div>
    <div id="tiles">
        <div id="tile-shadow" class="tile"></div>
    </div>
    <a class="icon" href="index.html"><img src="img/icon.png" style="width: 200px;"></img></a>
    <!-- <h1 class="ui timer"><span id="time-min">0</span>:<span id="time-sec">00</span></h1> -->
    <!-- <h1 class="ui score">0</h1> -->
    <div class="notify-msg"><div></div><img src="img/alert.png" style="height: 20px;"></img><span>SeaMonkey21 just forced a draw!</span></div>
    <button class="submit-btn control" onclick="tryDraw(this)"><img src="img/submit.png" style="height: 12px;"></img><span>draw</span></button>
    <img id="recenter-btn" src="img/recenter.png" onclick="recenterTiles()"></img>
    <h1 id="score" class="control">0</h1>
    <h1 id="timer" class="control"></h1>
    <img id="final-round-msg" src="img/final_round.png" class="progress-msg"></img>
    <img id="game-over-msg" src="img/game_over.png" class="progress-msg"></img>
    <h1 class="review-header">Let's see how everyone did...</h1>
    <h1 class="board-header"><span>SlickPossum18</span>'s deck
        <div id="trophy">
            <img class="trophy trophy-branch" src="img/trophy_branches.png"></img>
            <img class="trophy" src="img/single_trophy.png"></img>
        </div>
    </h1>
    <h1 id="review-score">0</h1>
    <img class="review-next" src="img/next.png" onclick="reviewNext()"></img>
    <!-- <div class="ui take-2" onclick="verifyTiles(tiles);">
        <div class="button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                    d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z">
                </path>
            </svg>
        </div>
    </div> -->
    <div id="overlay"></div>
    <!-- <script src="http://localhost:8080/target/target-script-min.js#anonymous"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script>
        var target, target_initial_position, contested_tile_position, tile_is_contested, exiled_tile;

        var grid_pos = [0, 0];
        var tile_size = 45;
        var panning = false;
        var mouse_initial_position = [0, 0];
        var grid_initial_position = [0, 0];
        var score_pos = [window.innerWidth - 100, window.innerHeight - 100];

        var tiles = {};
        var tid = 0;
        var dict = [];

        var score = 0;
        var time = 100;
        const seconds = document.getElementById("time-sec");
        const minutes = document.getElementById("time-min");
        var score_allowed = true;
        var tiles_locked = false;

        const grid = document.getElementById("background");
        const tile_container = document.getElementById("tiles");
        const tile_shadow = document.getElementById("tile-shadow");

        var anchor_pos = [window.innerWidth / 2, window.innerHeight / 2];
        setGridPos(anchor_pos);

        const alphamap = {
            " ": { draws: 2, value: 0 },
            "A": { draws: 9, value: 1 },
            "B": { draws: 2, value: 3 },
            "C": { draws: 2, value: 3 },
            "D": { draws: 4, value: 2 },
            "E": { draws: 12, value: 1 },
            "F": { draws: 2, value: 4 },
            "G": { draws: 3, value: 2 },
            "H": { draws: 2, value: 4 },
            "I": { draws: 9, value: 1 },
            "J": { draws: 1, value: 8 },
            "K": { draws: 1, value: 5 },
            "L": { draws: 4, value: 1 },
            "M": { draws: 2, value: 3 },
            "N": { draws: 6, value: 1 },
            "O": { draws: 8, value: 1 },
            "P": { draws: 2, value: 3 },
            "Q": { draws: 1, value: 10 },
            "R": { draws: 6, value: 1 },
            "S": { draws: 4, value: 1 },
            "T": { draws: 6, value: 1 },
            "U": { draws: 4, value: 1 },
            "V": { draws: 2, value: 4 },
            "W": { draws: 2, value: 4 },
            "X": { draws: 1, value: 8 },
            "Y": { draws: 2, value: 4 },
            "Z": { draws: 1, value: 10 },
        }
        const alphaweightmap = [];
        Object.keys(alphamap).forEach(c => alphaweightmap.push(...new Array(alphamap[c].draws).fill(c)));

        fetch("wordlist.txt").then(response => response.text()).then((data) => dict = data.split("\r\n"));

        // document.querySelectorAll(".tile").forEach((el) => {
        //     el.addEventListener("click", (e) => triggerAlert("touch"));
        // });

        document.ontouchstart = (e) => {
            const touch = e.touches[0];
            if (touch) {
                var override = false;
                document.elementsFromPoint(touch.pageX, touch.pageY).forEach((el) => {
                    if (el.classList.contains("tile")) {
                        override = true;
                        target = el;
                    }
                })
                if ((touch.target.classList.contains("tile") || override) && !tiles_locked) {
                    if (!override) target = touch.target;
                    target_initial_position = tiles[target.getAttribute("tid")].position;
                    tile_shadow.style.opacity = 1;
                    target.style.zIndex = 3;

                    var tid = target.getAttribute("tid");
                    var mouse_pos = [touch.pageX, touch.pageY];
                    var snap_pos = resolveGridPos(mouse_pos);
                    tiles[tid].position = snap_pos;
                    tileTwerp(target, snap_pos, 0.1);
                    tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
                }
                else if (score_allowed) {
                    panning = true;
                    mouse_initial_position = [touch.pageX, touch.pageY];
                    grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
                }
            }
        }
        document.ontouchend = (e) => {
            const touch = e.changedTouches[0];
            if (touch.target.getAttribute("id") == "background" || touch.target.classList.contains("tile")) {
                e.preventDefault();
            }
            if (target && touch && !tiles_locked) {
                var mouse_pos = [touch.pageX, touch.pageY];
                var snap_pos = snapToGrid(mouse_pos);
                var tid = target.getAttribute("tid");
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos);
                setTimeout(((jt) => target == jt ? null : jt.style.zIndex = 1).bind(null, target), 500);
                tile_shadow.style.opacity = 0;
                for (const stid of Object.keys(tiles)) {
                    if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                        tiles[stid].position = target_initial_position;
                        tileTwerp(tiles[stid].element, target_initial_position);
                    }
                }
                onTilesUpdate();
            }

            target = null;
            if (panning = true) onPanningFinished();
            panning = false;

            contested_tile_position = [null, null];
            tile_is_contested = false;
        }
        document.ontouchmove = (e) => {
            const touch = e.touches[0];
            if (target && touch && !tiles_locked) {
                var tid = target.getAttribute("tid");
                var mouse_pos = [touch.pageX, touch.pageY];
                var snap_pos = resolveGridPos(mouse_pos);

                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos, 0.1);
                tileTwerp(tile_shadow, snapToGrid(mouse_pos));
            }
            else if (panning && score_allowed) {
                var mouse_pos = [touch.pageX, touch.pageY];
                setGridPos(grid_initial_position.map((c, i) => c + mouse_pos[i] - mouse_initial_position[i]));
            }
        }

        document.onmousedown = (e) => {
            if (e.button == 0 && e.target.classList) {
                if (e.target.classList.contains("tile") && !tiles_locked) {
                    target = e.target;
                    target_initial_position = tiles[target.getAttribute("tid")].position;
                    tile_shadow.style.opacity = 1;
                    target.style.zIndex = 3;

                    var tid = target.getAttribute("tid");
                    var mouse_pos = [e.pageX, e.pageY];
                    var snap_pos = resolveGridPos(mouse_pos);
                    tiles[tid].position = snap_pos;
                    tileTwerp(target, snap_pos, 0.1);
                    tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
                }
                else if (score_allowed) {
                    panning = true;
                    mouse_initial_position = [e.pageX, e.pageY];
                    grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
                }
            }
        }
        document.onmouseup = (e) => {
            if (target && !tiles_locked) {
                var mouse_pos = [e.pageX, e.pageY];
                var snap_pos = snapToGrid(mouse_pos);
                var tid = target.getAttribute("tid");
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos);
                setTimeout(((jt) => target == jt ? null : jt.style.zIndex = 1).bind(null, target), 500);
                tile_shadow.style.opacity = 0;
                for (const stid of Object.keys(tiles)) {
                    if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                        tiles[stid].position = target_initial_position;
                        tileTwerp(tiles[stid].element, target_initial_position);
                    }
                }
                onTilesUpdate();
            }

            target = null;
            if (panning = true) onPanningFinished();
            panning = false;

            contested_tile_position = [null, null];
            tile_is_contested = false;
        }
        document.onmousemove = (e) => {
            if (target && !tiles_locked) {
                var tid = target.getAttribute("tid");
                var mouse_pos = [e.pageX, e.pageY];
                var snap_pos = resolveGridPos(mouse_pos);
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos, 0.1);
                tileTwerp(tile_shadow, snapToGrid(mouse_pos));
            }
            else if (panning && score_allowed) {
                var mouse_pos = [e.pageX, e.pageY];
                setGridPos(grid_initial_position.map((c, i) => c + mouse_pos[i] - mouse_initial_position[i]));
            }
        }

        // const proximity = 5;
        // document.onmousedown = (e) => {
        //     if (e.button == 0 && e.target.classList) {
        //         var mouse_pos = [e.pageX, e.pageY];
        //         function grabTile() {
        //             target_initial_position = tiles[target.getAttribute("tid")].position;
        //             tile_shadow.style.opacity = 1;
        //             target.style.zIndex = 3;

        //             var tid = target.getAttribute("tid");
        //             var snap_pos = resolveGridPos(mouse_pos);
        //             tiles[tid].position = snap_pos;
        //             tileTwerp(target, snap_pos, 0.1);
        //             tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
        //         }
        //         if (e.target.classList.contains("tile") && !tiles_locked) {
        //             target = e.target;
        //             grabTile();
        //         }
        //         else if (e.target.getAttribute("id") == "background" && !tiles_locked) {
        //             var nearest_tile;
        //             var nearest_dist = Infinity;
        //             Object.values(tiles).forEach(({ element, position }) => {
        //                 const mp = [mouse_pos[0] - grid_pos[0], mouse_pos[1] - grid_pos[1]];
        //                 const center = [position[0] + tile_size / 2, position[1] + tile_size / 2];
        //                 const distance = Math.sqrt((center[0] - mp[0]) ** 2 + (center[1] - mp[1]) ** 2);
        //                 const proximal = mp[0] >= position[0] - proximity && mp[0] <= position[0] + tile_size + proximity && mp[1] >= position[1] - proximity && mp[1] <= position[1] + tile_size + proximity;
        //                 if (proximal && distance < nearest_dist) {
        //                     console.log("new tile");
        //                     nearest_tile = element;
        //                     nearest_dist = distance;
        //                 }
        //             });
        //             if (nearest_tile) {
        //                 target = nearest_tile;
        //                 grabTile();
        //             }
        //         }
        //         if (score_allowed) {
        //             panning = true;
        //             mouse_initial_position = [e.pageX, e.pageY];
        //             grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
        //         }
        //     }
        // }
        // document.ontouchstart = (e) => {
        //     const touch = e.touches[0];
        //     if (touch) {
        //         var mouse_pos = [touch.pageX, touch.pageY];
        //         function grabTile() {
        //             target_initial_position = tiles[target.getAttribute("tid")].position;
        //             tile_shadow.style.opacity = 1;
        //             target.style.zIndex = 3;

        //             var tid = target.getAttribute("tid");
        //             var snap_pos = resolveGridPos(mouse_pos);
        //             tiles[tid].position = snap_pos;
        //             tileTwerp(target, snap_pos, 0.1);
        //             tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
        //         }
        //         if (touch.target.classList.contains("tile") && !tiles_locked) {
        //             target = touch.target;
        //             grabTile();
        //         }
        //         else if (touch.target.getAttribute("id") == "background" && !tiles_locked) {
        //             var nearest_tile;
        //             var nearest_dist = Infinity;
        //             Object.values(tiles).forEach(({ element, position }) => {
        //                 const mp = [mouse_pos[0] - grid_pos[0], mouse_pos[1] - grid_pos[1]];
        //                 const center = [position[0] + tile_size / 2, position[1] + tile_size / 2];
        //                 const distance = Math.sqrt((center[0] - mp[0]) ** 2 + (center[1] - mp[1]) ** 2);
        //                 const proximal = mp[0] >= position[0] - proximity && mp[0] <= position[0] + tile_size + proximity && mp[1] >= position[1] - proximity && mp[1] <= position[1] + tile_size + proximity;
        //                 if (proximal && distance < nearest_dist) {
        //                     console.log("new tile");
        //                     nearest_tile = element;
        //                     nearest_dist = distance;
        //                 }
        //             });
        //             if (nearest_tile) {
        //                 target = nearest_tile;
        //                 grabTile();
        //             }
        //         }
        //         if (score_allowed) {
        //             panning = true;
        //             mouse_initial_position = [touch.pageX, touch.pageY];
        //             grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
        //         }
        //     }
        // }

        function lockTiles() {
            tiles_locked = true;
            if (target) {
                var tid = target.getAttribute("tid");
                tiles[tid].position = snapToGrid(tiles[tid].position);
            }
        }

        function unlockTiles() {
            tiles_locked = false;
        }

        function selectTileByTID(tid) {
            return document.body.querySelector(`div[tid="${tid}"]`);
        }

        function startTimer() {
            var time_whole = 100;
            var time_start = performance.now();
            updateTimer();
            var time_inter = setInterval(() => {
                time = Math.round(time_whole - (performance.now() - time_start) / 1000);
                if (time <= 0) {
                    endTimer();
                    clearInterval(time_inter);
                }
                updateTimer();
            }, 1);
        }

        function updateTimer() {
            if (score_allowed) {
                var min = Math.floor(time / 60);
                var sec = time % 60;
                minutes.innerHTML = min;
                seconds.innerHTML = sec.toString().length == 1 ? "0" + sec : sec;
            }
        }

        // function endTimer() {

        // }

        // function take2() {
        //     createTileRow(["A", "B"]);
        // }

        function tileTwerp(target, position, duration = 0.2) {
            gsap.to(target, {
                duration: duration,
                x: position[0] + "px",
                y: position[1] + "px",
                overwrite: "auto"
            });
            determineBorderRadii();
        }

        function clearTiles() {
            for (var [i, tile] of Object.entries(tiles)) {
                gsap.to(tile.element, {
                    duration: 0.2,
                    scale: 0,
                    overwrite: "auto"
                });
            }
            setTimeout(() => {
                document.getElementById("tiles").innerHTML = "";
                tiles = {};
            }, 200);
        }

        function tileAppear(target) {
            gsap.to(target, {
                duration: 0.2,
                scale: 1,
                overwrite: "auto"
            });
        }

        function setGridPos(position, duration = 0.2, ease = "power4.out") {
            gsap.to(grid, {
                duration,
                backgroundPosition: `${position[0]}px ${position[1]}px`,
                ease,
                overwrite: "auto"
            });
            gsap.to(tile_container, {
                duration,
                x: position[0] + "px",
                y: position[1] + "px",
                ease,
                overwrite: "auto"
            });
            grid_pos = position;
        }

        function snapToGrid(position, tile_relative = true) {
            return position.map((c, i) => (tile_relative ? 0 : grid_pos[i]) + Math.floor((c - grid_pos[i]) / tile_size) * tile_size);
        }

        function resolveGridPos(position, tile_relative = true) {
            return position.map((c, i) => c - (tile_relative ? grid_pos[i] : 0) - tile_size / 2);
        }

        function cloneElement(tile, delay, color = "var(--light-green)", wild = false, el = document.getElementById("score"), border_radius) {
            setTimeout(() => {
                const is_valid = color == "var(--light-green)";
                var copy = tile.element.cloneNode(true);
                copy.style.borderRadius = border_radius;
                copy.style.backgroundColor = color;
                copy.style.boxShadow = "0 0 5px #00000033";
                copy.style.zIndex = 4;
                copy.style.position = "absolute";
                document.body.appendChild(copy);
                document.body.appendChild(copy);
                const position = [tile.position[0] + grid_pos[0], tile.position[1] + grid_pos[1]];
                gsap.set(copy, {
                    x: position[0],
                    y: position[1]
                });
                gsap.to(copy, {
                    duration: 0.5,
                    y: position[1] - tile_size/ (classic_score ? 2 : 4),
                    ease: "power4.out",
                    borderRadius: border_radius
                });
                if (is_valid) {
                    var score_ui_rect = el.getBoundingClientRect();
                    gsap.to(copy, {
                        duration: 1,
                        delay: classic_score ? 0.5 : 0.4,
                        x: score_ui_rect.left + score_ui_rect.width / 2 - tile_size / 2 + "px",
                        y: score_ui_rect.top + score_ui_rect.height / 2 - tile_size / 2 + "px",
                        ease: "power4.out",
                        borderRadius: tile_size / 5 + "px"
                    });
                    gsap.to(copy, {
                        duration: 0.5,
                        delay: 1.0,
                        scale: 0
                    });
                }
                else {
                    gsap.to(copy, {
                        duration: 0.5,
                        delay: 0.5,
                        y: position[1],
                        ease: "power4.out"
                    });
                    gsap.to(copy, {
                        duration: 0.5,
                        delay: 0.75,
                        opacity: 0,
                        ease: "power4.out"
                    });
                }
                setTimeout(() => document.body.removeChild(copy), 1200);
            }, delay);
        }

        function scoreTiles(tiles) {
            if (score_allowed) {
                score_allowed = false;
                var words = getWordMap(tiles);
                var score = 0;
                var delay = 0;
                for (var i = 0; i < words.length; i++) {
                    var s = (words[i].valid ? 1 : -1) * getWordScore(words[i].word);
                    score += s;
                    for (var j = 0; j < words[i].tiles.length; j++) {
                        const tile = words[i].tiles[j];
                        cloneElement(tile, delay, words[i].valid ? "var(--light-green)" : (words[i].disconnected ? "var(--light-yellow)" : "var(--light-red)"));
                        delay += 50;
                    }
                }
                var score_ui = document.querySelector(".ui.score");
                var bonus = score > score_ui.innerText;
                for (var i = 0; i < Math.abs(score - score_ui.innerText); i++) setTimeout(() => score_ui.innerText = parseInt(score_ui.innerText) + (bonus ? 1 : -1), delay + 1000 + i * 10);
                setTimeout(() => {
                    take2();
                    score_allowed = true;
                }, delay + 500);
            }
        }

        function createTile(letter, value, position, delay = 0) {
            const stid = JSON.parse(JSON.stringify(tid));
            tid++;
            var tile_element = document.createElement("div");
            tile_element.classList.add("tile");
            tile_element.setAttribute("tid", stid);
            tile_element.setAttribute("letter", letter);
            tile_element.innerHTML = letter;
            var value_element = document.createElement("span");
            value_element.classList.add("value");
            value_element.innerHTML = value;
            tile_element.appendChild(value_element);
            tile_container.appendChild(tile_element);
            tiles[stid] = { position, element: tile_element, tid: stid, letter };
            tileTwerp(tile_element, position, 0);
            gsap.set(tile_element, { scale: 0 });
            setTimeout(() => tileAppear(tile_element), delay);
            onTilesUpdate();
            return stid;
        }

        function determineBorderRadii() {
            for (var tile of Object.values(tiles)) {
                // top-left, top-right, bottom-right, bottom-left
                var el = tile.element;
                var radius = tile_size / 5;
                var vert = [false, false];
                var horiz = [false, false];
                for (var stile of Object.values(tiles)) {
                    if (stile.tid != tile.tid) {
                        if (stile.position[1] == tile.position[1]) {
                            if (stile.position[0] == tile.position[0] + tile_size) horiz[1] = true;
                            else if (stile.position[0] == tile.position[0] - tile_size) horiz[0] = true;
                        }
                        else if (stile.position[0] == tile.position[0]) {
                            if (stile.position[1] == tile.position[1] + tile_size) vert[1] = true;
                            else if (stile.position[1] == tile.position[1] - tile_size) vert[0] = true;
                        }
                    }
                }
                var borders = [vert[0] || horiz[0], vert[0] || horiz[1], vert[1] || horiz[1], vert[1] || horiz[0]];
                el.style.borderRadius = `${borders[0] ? 0 : radius}px ${borders[1] ? 0 : radius}px ${borders[2] ? 0 : radius}px ${borders[3] ? 0 : radius}px`;
            }
        }

        function pickRandomTile() {
            return alphaweightmap[Math.round(Math.random() * (alphaweightmap.length - 1))];
        }

        function createTileRow(letters, twerp = true) {
            const size = letters.length;
            var pos = [-Math.round(size/2)*tile_size, 0];
            if (Object.keys(tiles).length > 0) {
                var vertex_tile = Math.max.apply(null, Object.keys(tiles).map((tile) => tiles[tile].position[1]));
                pos[1] = vertex_tile + tile_size * 2;
            }
            for (var i = 0; i < size; i++) {
                createTile(letters[i], alphamap[letters[i]].value, JSON.parse(JSON.stringify(pos)), i*100);
                pos[0] += tile_size;
            }
            if (twerp) setGridPos([anchor_pos[0] + tile_size * (size % 2) * 0.5, -pos[1] + anchor_pos[1]], 0.5, "power4.out");
        }

        function getAllWords(tiles) {
            var axes = [{}, {}];
            for (var [i, tile] of Object.entries(tiles)) {
                for (var j = 0; j < 2; j++) {
                    if (!axes[j].hasOwnProperty(tile.position[j])) axes[j][tile.position[j]] = [];
                    axes[j][tile.position[j]].push(tile);
                }
            }

            var tile_groups = [];
            for (var j = 0; j < 2; j++) {
                for (var [k, unsorted] of Object.entries(axes[j])) {
                    var consecutive = [];
                    var prev = null;
                    var sorted = unsorted.sort((a, b) => a.position[1 - j] - b.position[1 - j]);
                    for (var tile of sorted) {
                        var axis = tile.position[1 - j] / tile_size;
                        if (Math.abs(axis - prev) <= 1 || prev == null) consecutive.push(tile);
                        else {
                            if (consecutive.length > 1) tile_groups.push(consecutive);
                            consecutive = [tile];
                            prev = null;
                        }
                        prev = axis;
                    }
                    if (consecutive.length > 1) tile_groups.push(consecutive);
                }
            }

            var words = [];
            for (var group of tile_groups) words.push({ word: group.map((c) => c.letter).join(""), tiles: group });
            return words;
        }

        function recenterTiles() {
            var far_left, far_top, far_right, far_bottom;
            for (var [i, tile] of Object.entries(tiles)) {
                if (tile.position[0] < far_left || far_left == null) far_left = tile.position[0];
                if (tile.position[0] > far_right || far_right == null) far_right = tile.position[0];
                if (tile.position[1] < far_top || far_top == null) far_top = tile.position[1];
                if (tile.position[1] > far_bottom || far_bottom == null) far_bottom = tile.position[1];
            }
            const center = [(far_right + far_left)/2 + tile_size/2, (far_bottom + far_top)/2 + tile_size/2];
            setGridPos([anchor_pos[0] - center[0], anchor_pos[1] - center[1]], 0.5, "power4.out");
            onPanningFinished();
        }

        function tileInScreen(tile) {
            const adjusted_pos = [grid_pos[0] + tile.position[0], grid_pos[1] + tile.position[1]];
            return !(adjusted_pos[0] < 0 || adjusted_pos[0] > window.innerWidth || adjusted_pos[1] < 0 || adjusted_pos[1] > window.innerHeight);
        }

        function findWildWords(word) {
            var possible_words = [];
            for (var dict_word of dict) {
                if (dict_word.length == word.length) {
                    var break_flag = false;
                    for (var i = 0; i < dict_word.length; i++) {
                        if (word[i] != " " && word[i] != dict_word[i]) {
                            break_flag = true;
                            break;
                        }
                    }
                    if (!break_flag) possible_words.push(dict_word);
                }
            }
            return possible_words;
        }

        function checkValidWords(words) {
            var word_map = words;
            for (var group of word_map) {
                if (!group.word.includes(" ")) group.valid = dict.includes(group.word);
            }

            var wild_tiles = {};
            for (var group of word_map) {
                if (group.word.includes(" ")) {
                    for (var tile of group.tiles) {
                        if (tile.letter == " ") {
                            if (wild_tiles.hasOwnProperty(tile.tid)) wild_tiles[tile.tid].push(group);
                            else wild_tiles[tile.tid] = [group];
                        }
                    }
                }
            }
            for (var tid of Object.keys(wild_tiles)) {
                var word_options = [];
                var stop_flag = false;

                for (var group of wild_tiles[tid]) {
                    var possibilities = findWildWords(group.word);
                    if (possibilities.length > 0) {
                        var wild_indices = group.word.split("").map((c, i) => i).filter((c) => group.word[c] == " ");
                        var this_wild_index = group.tiles.map((c, i) => c = { i, tid: c.tid }).filter((c) => c.tid == tid)[0].i;
                        word_options.push({ possibilities, index: this_wild_index });
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                        stop_flag = true;
                    }
                }

                if (!stop_flag) {
                    var possible_substitutions = [];
                    for (var option of word_options) {
                        var possible_substitution = option.possibilities.map((c) => c[option.index]);
                        possible_substitutions.push(possible_substitution);
                    }

                    var valid = possible_substitutions.slice(1).every(array => array.some(el => possible_substitutions[0].includes(el)));
                    if (valid) {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0 && !group.hasOwnProperty("valid")) group.valid = true;
                        }
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                    }
                }
            }

            return word_map;
        }

        function getSingles(words) {
            var word_ids = words.flatMap((c) => c.tiles.map((d) => d.tid));
            var all_ids = Object.keys(tiles).map((c) => tiles[c].tid);
            var single_ids = all_ids.filter((c) => !word_ids.includes(c));
            var singles = single_ids.map((c) => tiles[c]);
            return singles;
        }

        // function getScore(tiles) {
        //     var score = 0;
        //     var words = getWordMap(tiles);
        //     for (var group of words) score += (group.valid ? 1 : 0)*group.word.split("").reduce((psum, c) => psum + alphamap[c].value, 0);
        //     return score;
        // }

        function getWordScore(word) {
            return word.split("").reduce((psum, c) => psum + alphamap[c].value, 0)
        }

        function getScore(words) {
            var score = 0;
            for (var group of words) score += (group.valid ? 1 : 0) * getWordScore(group.word);
            return score;
        }

        function calculateScore(word) {
            var score = 0;
            for (var letter of word) score += alphamap[letter].value;
            return score;
        }

        function getConsecutiveTileGroups(tiles) {
            var visited = new Set();
            var groups = [];

            function getAdjacents(tile) {
                var adjacents = [];
                for (var stile of Object.values(tiles)) {
                    if (stile.tid != tile.tid) {
                        var x_diff = Math.abs(stile.position[0] - tile.position[0]);
                        var y_diff = Math.abs(stile.position[1] - tile.position[1]);
                        if ((x_diff <= tile_size && y_diff <= tile_size) && (x_diff == 0 || y_diff == 0) && !(x_diff == 0 && y_diff == 0)) {
                            adjacents.push(stile);
                        }
                    }
                }
                return adjacents;
            }

            function firstSearch(tile, group) {
                visited.add(tile.tid);
                group.push(tile);
                var adjacents = getAdjacents(tile);
                if (adjacents.length > 0) {
                    for (var adjacent of adjacents) {
                        if (!visited.has(adjacent.tid)) {
                            firstSearch(adjacent, group);
                        }
                    }
                }
                else groups.push([tile]);
            }

            for (var tile of Object.values(tiles)) {
                if (!visited.has(tile.id)) {
                    var group = [];
                    firstSearch(tile, group);
                    if (group.length > 1) groups.push(group);
                }
            }

            return groups;
        }

        function calculateConnectionPenalties(words) {
            var word_map = words;
            var groups = getConsecutiveTileGroups(tiles);
            var scores = groups.map((c) => getScore(checkValidWords(getAllWords(c))));
            var penalized_groups = groups.filter((c, i) => i != scores.indexOf(Math.max(...scores)));
            var penalized_tile_tids = penalized_groups.flat().map((c) => c.tid);
            var singles = penalized_groups.filter((c) => c.length == 1);
            for (var group of word_map) {
                for (var tile of group.tiles) {
                    if (penalized_tile_tids.includes(tile.tid)) {
                        if (group.valid) group.disconnected = true;
                        group.valid = false;
                    }
                }
            }
            for (var tile of singles) word_map.push({ word: tile[0].letter, tiles: [tile[0]], valid: false });
            return word_map;
        }

        function getWordMap(tiles) {
            var words = getAllWords(tiles);
            words = checkValidWords(words);
            words = calculateConnectionPenalties(words);
            return words;
        }
        //createTileRow(2);
    </script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script>
        const config = {
            apiKey: "AIzaSyCYiF56kcc8XriibM-KGFcGfhfYYtvyQ1s",
            authDomain: "vocabulum-220c3.firebaseapp.com",
            projectId: "vocabulum-220c3",
            storageBucket: "vocabulum-220c3.firebasestorage.app",
            messagingSenderId: "143266091587",
            appId: "1:143266091587:web:aa07a256380819be63faf6",
            measurementId: "G-5SFXW24TDN"
        }
        const app = firebase.initializeApp(config);
        const database = firebase.database();
        const empty_promise = () => {
            return { then: () => {} }
        };
        var ref = (r) => firebase.database().ref(r);

        //const params = new URLSearchParams(window.location.href.split("?")[1]);
        const my_type = sessionStorage.getItem("t");
        const my_id = sessionStorage.getItem("id");
        const my_name = sessionStorage.getItem("n");
        const my_lobby = sessionStorage.getItem("l");

        const my_lobby_path = "lobbies/" + my_lobby + "/";
        const my_lobby_data_path = my_lobby_path + "data/";
        const my_mem_path = my_lobby_path + "members/" + my_id + "/";
        const my_data_path = my_mem_path + "data/";

        const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
        const npick = (arr, n) => Array(n).fill(0).map((x) => pick(arr));
        const idraw = (deck) => deck.splice(Math.floor(Math.random()*deck.length), 1)[0];
        const ndraw = (deck, n) => Array(n).fill(0).map((x) => x = idraw(deck));
        const nrep = (arr, n) => Array(n).fill(arr).flat();
        
        var draw_timeout;
        var draw_start_date;
        var alert_close_timeout;
        var final_round = false;
        var game_over = false;

        const auto_draw_delay = (my_type == "classic" ? 60 : 90)*1000;

        window.onscroll = ((e) => e.preventDefault());

        function triggerProgressMessage(id, delay = 2000) {
            const msg = document.getElementById(id);
            msg.classList.add("active");
            setTimeout(() => msg.classList.remove("active"), delay);
        }

        function triggerBoardHeader(name, trophy = false) {
            const board_header = document.querySelector(".board-header");
            const review_score = document.getElementById("review-score");
            board_header.classList.remove("active");
            review_score.classList.remove("active");
            setTimeout(() => {
                if (trophy) document.querySelectorAll(".trophy").forEach((el) => el.classList.add("active"));
                else document.querySelectorAll(".trophy").forEach((el) => el.classList.remove("active"));
                board_header.querySelector("span").innerText = name;
                setTimeout(() => review_score.innerText = "0", 100);
                board_header.classList.add("active");
                review_score.classList.add("active");
            }, 300);
        }

        function onPanningFinished() {
            const recenter_btn = document.getElementById("recenter-btn");
            var tiles_hidden = true;
            for (const [i, tile] of Object.entries(tiles)) {
                if (tileInScreen(tile)) {
                    tiles_hidden = false;
                    break;
                }
            }
            if (tiles_hidden) recenter_btn.classList.add("active");
            else recenter_btn.classList.remove("active");
        }

        function triggerAlert(content) {
            document.querySelector(".notify-msg").classList.remove("active");
            if (alert_close_timeout) {
                clearTimeout(alert_close_timeout);
                alert_close_timeout = null;
            }
            setTimeout(() => {
                document.querySelector(".notify-msg span").innerText = content;
                document.querySelector(".notify-msg").classList.add("active");
                alert_close_timeout = setTimeout(() => document.querySelector(".notify-msg").classList.remove("active"), 3000);
            }, 100);
        }

        function tryDraw(el = null, display = false) {
            if (el) {
                el.classList.add("active");
                setTimeout(() => el.classList.remove("active"), 200);
            }

            if (score_allowed) {
                score_allowed = false;
                const score_display = document.getElementById(display ? "review-score" : "score");
                lockTiles();
                var words = getWordMap(tiles);
                var delay = 0;
                var score = 0;
                var all_valid = true;
                words = words.sort((a, b) => b.valid - a.valid);
                for (var i = 0; i < words.length; i++) {
                    if (!words[i].valid) {
                        all_valid = false;
                        score -= words[i].word.length;
                    }
                    else score += getWordScore(words[i].word);
                    var vert = null;
                    if (words[i].tiles.length > 1) var vert = words[i].tiles[0].position[0] == words[i].tiles[1].position[0];
                    for (var j = 0; j < words[i].tiles.length; j++) {
                        const tile = words[i].tiles[j];
                        const radius = tile_size / 5;
                        var border_radius = `${radius}px`;
                        if (vert != null) {
                            if (vert) { 
                                if (j == 0) border_radius = `${radius}px ${radius}px 0 0`;
                                else if (j == words[i].tiles.length - 1) border_radius = `0 0 ${radius}px ${radius}px`;
                                else border_radius = "0";
                            }
                            else {
                                if (j == 0) border_radius = `${radius}px 0 0 ${radius}px`;
                                else if (j == words[i].tiles.length - 1) border_radius = `0 ${radius}px ${radius}px 0`;
                                else border_radius = "0";
                            }
                        }
                        cloneElement(tile, delay, words[i].valid ? "var(--light-green)" : (words[i].disconnected ? "var(--light-yellow)" : "var(--light-red)"), false, score_display, classic_score ? `${radius}px` : border_radius);
                        delay += classic_score ? 50 : 10;
                    }
                    delay += classic_score ? 0 : words[i].tiles.length * 30;
                }
                const prev_score = parseInt(score_display.innerText);
                const inc_dir = (score > prev_score ? 1 : -1);
                var temp_score = prev_score;
                for (var i = 0; i < Math.abs(score - prev_score); i++) setTimeout(() => {
                    temp_score += inc_dir;
                    score_display.innerText = temp_score;
                }, delay + 500 + i*10);
                setTimeout(() => {
                    if (!display) {
                        unlockTiles();
                        if (final_round) {
                            if (all_valid) {
                                if (my_type == "classic") onClassicWin();
                                else ref(my_lobby_data_path + "winner_id").set(my_id);
                            }
                            else triggerAlert("need to finish deck first!");
                        }
                        else {
                            if (all_valid) {
                                if (my_type == "classic") {
                                    createTileRow(ndraw(deck, 2));
                                    if (deck.length >= 2) setTimer(auto_draw_delay, classic_timer_callback);
                                    else startFinalRound();
                                }
                                else assignDraws(2);
                            }
                            else if (my_type == "classic" && !classic_timed) {
                                createTileRow(ndraw(deck, 2));
                                if (deck.length >= 2) setTimer(auto_draw_delay, classic_timer_callback);
                                else startFinalRound();
                            }
                            else triggerAlert("need to finish deck first!");
                        }
                    }
                    else document.querySelector(".review-next").classList.add("active");
                    score_allowed = true;
                }, delay + (classic_score ? 1000 : 900));
            }
        }

        const full_deck = [...alphaweightmap];
        var deck = full_deck;

        function createInitialDeck(mem_count) {
            const draws_per_game = 12;
            const tiles_per_player = 7 + 2*draws_per_game;
            const tiles_total = tiles_per_player*mem_count;
            var full_decks_count = Math.floor(tiles_total / full_deck.length);
            var extra_tiles_count = Math.floor(tiles_total % full_deck.length);
            deck = nrep(full_deck, full_decks_count).concat(npick(full_deck, extra_tiles_count));
            return deck;
        }

        function assignDraws(n, init = false, auto = false) {
            ref(my_lobby_path + "members").once("value").then((snapshot) => {
                const members = snapshot.val();
                const mem_count = Object.keys(members).length;
                if (init) createInitialDeck(mem_count);
                ref(my_lobby_data_path + "deck").once("value").then((snapshot) => {
                    if (snapshot.exists()) deck = snapshot.val().split("");
                    ref(my_lobby_data_path + "drawer").set(init ? "initial" : (auto ? "auto" : my_name));
                    for (const mid of Object.keys(members)) {
                        const mem = members[mid];
                        const draw = ndraw(deck, n).join("");
                        ref(my_lobby_path + "members/" + mid + "/data/draw").set(draw);
                        ref(my_lobby_path + "members/" + mid + "/data/draw_history").push(draw);
                    }
                    ref(my_lobby_data_path + "last_draw_date").set(new Date().toISOString());
                    ref(my_lobby_data_path + "deck").set(deck.join(""));
                    onTilesUpdate();

                    if (deck.length < mem_count*2) {
                        ref(my_lobby_data_path + "final_round").set(true);
                    }
                })
            });
        }

        function restoreTilesFromBlob(blob) {
            for (const blob_tile of blob) {
                const position = [blob_tile.position.x, blob_tile.position.y];
                const letter = blob_tile.letter;
                createTile(letter, alphamap[letter].value, position);
            }
            recenterTiles();
        }

        function blobifyTiles() {
            const blob = [];
            for (const key of Object.keys(tiles)) {
                const tile = tiles[key];
                blob.push({
                    position: {
                        x: tiles[key].position[0],
                        y: tiles[key].position[1]
                    },
                    letter: tiles[key].letter
                });
            }
            return blob;
        }

        function onTilesUpdate() {
            if (my_type != "classic") ref(my_lobby_path + "members/" + my_id + "/data/tiles").set(blobifyTiles());
        }

        function onRefUpdate(r, callback = () => {}) {
            var ct = 0;
            const l = r.on("value", (snapshot) => {
                if (ct++ == 1) {
                    r.off("value", l);
                    callback(snapshot);
                }
            });
        }

        function setTimer(delay = auto_draw_delay, callback = () => assignDraws(2, false, true)) {
            if (draw_timeout) clearTimeout(draw_timeout);
            draw_timeout = setTimeout(() => {
                if (!final_round) {
                    callback();
                    setTimer();
                }
            }, delay);
            draw_start_date = new Date(new Date().getTime() - (auto_draw_delay - delay));
        }

        function displayBoard(t_blob) {
            clearTiles();
            triggerBoardHeader(t_blob.name, t_blob.winner);
            setTimeout(() => restoreTilesFromBlob(t_blob.blob), 500);
            setTimeout(() => tryDraw(null, true), 1000);
        }

        var blob_i = 0;
        var t_blobs = [];
        function reviewNext() {
            if (++blob_i == t_blobs.length - 1) {
                setTimeout(() => {
                    document.querySelector(".review-next").src = "img/exit.png";
                    document.querySelector(".review-next").onclick = redirect;
                    if (my_type == "classic") document.querySelector(".review-next").classList.add("classic");
                    document.querySelector(".review-next").classList.add("active");
                }, 300);
            }
            const current_blob = t_blobs[blob_i % t_blobs.length];
            displayBoard(current_blob);
            document.querySelector(".review-next").classList.remove("active");
        }

        function onClassicWin() {
            lockTiles();
            triggerProgressMessage("game-over-msg");
            game_over = true;
            document.querySelector(".submit-btn").classList.add("hidden");
            document.querySelector(".review-next").src = "img/exit.png";
            document.querySelector(".review-next").onclick = redirect;
            document.querySelector(".review-next").classList.add("classic");
            document.querySelector(".review-next").classList.add("active");
            end_time = new Date() - start_date;
            if (classic_timed) document.getElementById("timer").classList.add("hidden");
        }

        function redirect() {
            //window.location.href = `index.html?t=${my_type}&id=${my_id}&n=${my_name}&l=${my_lobby}`;
            ref(my_lobby_path + "members").transaction((post) => {
                if (post) {
                    for (const mid of Object.keys(post)) post[mid].data = {};
                    return post;
                }
            })
            ref(my_lobby_data_path).set({});
            ref(my_lobby_path + "locked").set(false);
            ref(my_lobby_path + "initial_drawn").set(false);
            ref(my_lobby_path + "start").set(false);
            ref(my_lobby_path + "winner_id").set(null);
            window.location.href = "index.html";
        }

        function startFinalRound() {
            final_round = true;
            triggerProgressMessage("final-round-msg");
            const sumbit_btn = document.querySelector(".submit-btn");
            sumbit_btn.style.transition = "transform 0.3s ease, opacity 0.3s ease"
            console.log(sumbit_btn.style.transition);
            setTimeout(() => sumbit_btn.classList.add("hidden"), 100);
            setTimeout(() => {
                sumbit_btn.classList.add("final-round");
                sumbit_btn.querySelector("span").innerText = "finish!";
                sumbit_btn.classList.remove("hidden");
            }, 300);
            setTimeout(() => sumbit_btn.style.transition = "", 500);
            document.getElementById("timer").style.display = "none";
            if (draw_timeout) clearTimeout(draw_timeout);
        }

        if (my_type != "classic") document.addEventListener("DOMContentLoaded", () =>  {
            // restore connection
            if (my_type == "host" || my_id == 0) ref(my_lobby_path + "initial_drawn").once("value").then((snapshot) => {
                if (!snapshot.exists() || !snapshot.val()) {
                    assignDraws(7, true);
                    ref(my_lobby_path + "initial_drawn").set(true);
                }
            })
            ref(my_lobby_path + "members/" + my_id + "/data/tiles").once("value").then((snapshot) => {
                if (snapshot.exists()) {
                    restoreTilesFromBlob(snapshot.val());
                    triggerAlert("connection restored!");
                    ref(my_data_path + "draws_received").once("value").then((snapshot) => {
                        if (snapshot.exists()) {
                            const draws_received = snapshot.val();
                            ref(my_data_path + "draw_history").once("value").then((snapshot) => {
                                if (snapshot.exists()) {
                                    const draw_history = Object.values(snapshot.val());
                                    const intended_draws_received = draw_history.length;
                                    if (draws_received < intended_draws_received) {
                                        const draws_to_add = draw_history.slice(draws_received);
                                        for (const draw of draws_to_add) createTileRow(draw.split(""), false);
                                        ref(my_data_path + "draws_received").set(intended_draws_received);
                                        recenterTiles();
                                    }
                                }
                            });
                        }
                    });
                }
                // else if (my_type == "host" || my_id == "0") assignDraws(7, true);
            });

            // on someone draws
            var ct = 0;
            ref(my_data_path + "draw").on("value", (snapshot) => {
                if (snapshot.exists()) {
                    const letters = snapshot.val().split("");
                    if (ct++ > 0) {
                        ref(my_lobby_data_path + "drawer").once("value").then((snapshot) => {
                            const drawer = snapshot.val();
                            var twerp = true;
                            if (drawer) {
                                if (drawer != "initial" && drawer != my_name && drawer != "auto") {
                                    triggerAlert(drawer + " just forced a draw!");
                                    twerp = false;
                                }
                                else if (drawer == "auto") {
                                    triggerAlert("everyone given a helping hand");
                                    twerp = false;
                                }
                            }
                            if (my_type == "host") setTimer();
                            createTileRow(letters, twerp);
                            ref(my_data_path + "draws_received").transaction((post) => {
                                if (post) return post + 1;
                                else return 1;
                            });
                        });
                    }
                    else if (Object.keys(tiles).length == 0) createTileRow(letters, true);
                }
            });

            // on draw date update
            var cdt = 0;
            ref(my_lobby_data_path + "last_draw_date").on("value", (snapshot) => {
                if (snapshot.exists()) {
                    if (cdt++ == 0 && my_type == "host") {
                        const time_difference = new Date() - new Date(snapshot.val());
                        if (time_difference >= auto_draw_delay) {
                            assignDraws(2, false, true);
                            setTimer();
                        }
                        else setTimer(auto_draw_delay - time_difference);
                    }
                    else draw_start_date = new Date(snapshot.val());
                }
            });

            // on final round declaration
            ref(my_lobby_data_path + "final_round").on("value", (snapshot) => {
                if (snapshot.val()) {
                    ref(my_lobby_data_path + "winner_id").once("value").then((snapshot) => {
                        if (!snapshot.val()) startFinalRound();
                    });
                }
            });
            
            // on winner declaration
            ref(my_lobby_data_path + "winner_id").on("value", (snapshot) => {
                const winner_id = snapshot.val();
                if (winner_id) {
                    lockTiles();
                    triggerProgressMessage("game-over-msg");
                    game_over = true;
                    document.querySelector(".submit-btn").classList.add("hidden");
                    document.getElementById("timer").classList.add("hidden");
                    document.getElementById("score").classList.add("hidden");
                    if (draw_timeout) clearTimeout(draw_timeout);
                    clearTiles();
                    setTimeout(() => {
                        setTimeout(() => document.querySelector(".review-header").classList.add("active"), 200);
                        ref(my_lobby_path + "members").once("value").then((snapshot) => {
                            const members = snapshot.val();
                            for (const [mid, mem] of Object.entries(members)) {
                                const blob = mem.data.tiles;
                                const is_winner = mid == winner_id;
                                if (blob) {
                                    const t_blob = {
                                        name: mem.name,
                                        blob,
                                        winner: is_winner
                                    }
                                    if (is_winner) t_blobs.unshift(t_blob);
                                    else t_blobs.push(t_blob);
                                }
                            }
                            displayBoard(t_blobs[0]);
                        });
                    }, 2000);
                }
            });
        });

        const classic_timed = false;
        const classic_score = false;
        const start_date = new Date();
        var end_time = 0;
        const classic_timer_callback = () => {
            createTileRow(ndraw(deck, 2));
            triggerAlert("given a helping hand");
        }
        if (my_type == "classic") {
            createInitialDeck(1);
            const initial_draw = ndraw(deck, 7).join("").replaceAll("Q", "A").split("");
            setTimeout(() => createTileRow(initial_draw), 500);
            if (classic_timed) setTimer(auto_draw_delay, classic_timer_callback);
        }

        setInterval(() => {
            var total_seconds = (auto_draw_delay - (new Date() - draw_start_date))/1000;
            if (my_type == "classic" && !classic_timed) var total_seconds = (new Date() - start_date) / 1000;
            if (my_type == "classic" && !classic_timed && game_over) var total_seconds = end_time / 1000
            const mins = Math.max(0, Math.floor(total_seconds / 60));
            const secs = Math.max(0, Math.floor(total_seconds % 60));
            const text = mins + ":" + (secs < 10 ? "0" : "") + secs;
            document.getElementById("timer").innerHTML = text.split("").map((l) => `<span>${l}</span>`).join("");
        }, 100);
    </script>
    <script>
    </script>
</body>

</html>