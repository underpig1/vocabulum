<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700;1000&display=swap" rel="stylesheet">
    <title>Vocabulum</title>
    <style>
        :root {
            --bg-grid-color: #00000017;
            --tile-size: 45px;
            --tile-color: #f9be74ff;
            --font-color: #333;

            --light-red: #ff9080ff;
            --light-yellow: #f0df70ff;
            --light-green: #80df70ff;
        }

        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            user-select: none;
            touch-action: manipulation;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            user-select: none;
            overflow: hidden;
        }

        #background {
            width: 100vw;
            height: 100vh;
            margin: 0;
            background-size: var(--tile-size) var(--tile-size);
            background-image: linear-gradient(to right, var(--bg-grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--bg-grid-color) 1px, transparent 1px);
            background-position: 0 0;
        }

        .tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            background-color: var(--tile-color);
            border-radius: calc(var(--tile-size)/5);
            text-align: center;
            line-height: calc(var(--tile-size) + var(--tile-size)/12);
            font-size: calc(var(--tile-size)/1.7);
            font-family: 'Comfortaa', sans-serif;
            font-weight: bold;
            cursor: pointer;
            top: 0;
            left: 0;
            transition: border-radius 0.2s;
            /* transition: transform 0.2s, top 0.1s, left 0.1s; */
        }

        #tile-shadow {
            background-color: #00000055;
            opacity: 0;
            z-index: 2;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .tile:active {
            /* transform: scale(0.85); */
        }

        .tile>.value {
            position: absolute;
            left: calc(var(--tile-size)/7);
            top: calc(var(--tile-size)/7);
            line-height: calc(var(--tile-size)/4);
            font-size: calc(var(--tile-size)/4);
            pointer-events: none;
        }

        #tiles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        .ui {
            position: absolute;
            font-size: 16px;
            line-height: 16px;
            font-size: calc(var(--tile-size)/1.5);
            font-family: 'Comfortaa', sans-serif;
            color: var(--font-color);
            font-weight: bold;
            margin: 0;
            pointer-events: none;
            bottom: 35px;
        }

        .timer {
            right: 35px;
        }

        .score {
            left: 35px;
        }

        .tile[tid="-1"] {
            pointer-events: none;
        }

        .take-2 {
            display: flex;
            width: 100%;
            height: 60px;
            margin-bottom: -15px;
            justify-content: center;
        }

        .take-2>div {
            display: flex;
            width: 85px;
            height: 100%;
            background-color: var(--light-green);
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.1s;
            transform: scale(0.9);
        }

        .take-2 svg {
            fill: white;
            width: 50%;
        }

        .take-2:active div {
            transform: scale(0.85);
        }

        .button {
            width: 90%;
            height: 66px;
            background-color: var(--light-red);
            border-radius: 15px;
            border: solid 5px #333;
            box-shadow: 0px 5px 0px 0px #333;
            font-family: 'Comfortaa', sans-serif;
            font-size: 28px;
            text-align: center;
            line-height: 57px;
            font-weight: 1000;
            color: #333;
            transform: translateY(-5px);
            z-index: 2;
        }

        .buttons {
            z-index: 4;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 230px;
            margin-top: 50%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-direction: column;
        }

        .buttons>.button:active {
            transform: translateY(0);
            box-shadow: 0px 0px 0px 0px #333;
        }

        #overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%;
            right: 0;
            animation: overlay 1s ease-out forwards;
            background-color: black;
            display: block;
            z-index: 3;
        }

        @keyframes overlay {
            0% {
                height: 100%;
            }
            100% {
                height: 0;
                display: none;
            }
        }

        .icon {
            position: absolute;
            top: 35px;
            left: 50px;
        }

        .submit-btn {
            position: absolute;
            bottom: 50px;
            display: flex;
            line-height: 65px;
            flex-direction: row;
            justify-content: center;
            gap: 10px;
            align-items: center;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 50px);
            max-width: 300px;
            height: 65px;
            font-size: 14pt;
            outline: none;
            border: 4px black solid;
            padding: 0 15px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 600;
            filter: drop-shadow(0 5px 0 black);
            color: black;
            background-color: #93f46fff;
            margin-right: auto;
            border-radius: 15px;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .submit-btn:hover {
            transform: translateX(-50%) scale(0.95);
        }

        .submit-btn:active {
            transform: translateX(-50%) scale(0.93);
        }

        .notify-msg {
            position: absolute;
            top: 35px;
            right: 50px;
            display: flex;
            line-height: 60px;
            flex-direction: row;
            justify-content: center;
            gap: 15px;
            align-items: center;
            width: max-content;
            height: 60px;
            font-size: 12pt;
            outline: none;
            padding: 0 25px;
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            color: black;
            background-color: #c9c9c9;
            margin-right: auto;
            cursor: pointer;
            border: 4px black solid;
            filter: drop-shadow(0 5px 0 black);
            border-radius: 15px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            z-index: 4;
        }

        .notify-msg * {
            opacity: 0.9;
        }

        .notify-msg.active {
            opacity: 1;
            transform: none;
        }

        .notify-msg div {
            background-color: #dbdbdb;
            display: block;
            position: absolute;
            width: 0;
            left: 0;
            top: 0;
            bottom: 0;
            border-radius: 15px 0 0 15px;
        }

        .notify-msg.active div {
            animation: notify-move 3s linear forwards;
        }

        #timer {
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            font-size: 18pt;
            position: absolute;
            bottom: 50px;
            right: 50px;
        }

        #timer span {
            display: inline-block;
            width: 0.7em;
            text-align: center;
        }

        #score {
            font-family: 'Poppins', Helvetica, sans-serif;
            font-weight: 500;
            font-size: 18pt;
            position: absolute;
            bottom: 50px;
            left: 50px;
        }

        @keyframes notify-move {
            0% {
                width: 0;
            }
            90% {
                width: 90%;
                border-radius: 15px 0 0 15px;
            }
            100% {
                width: 100%;
                border-radius: 15px;
            }
        }

        #recenter-btn {
            position: absolute;
            top: 35px;
            right: 50px;
            width: 30px;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.8);
            transition: transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none;
        }

        #recenter-btn.active {
            transform: scale(1);
            opacity: 1;
            pointer-events: all;
        }
    </style>
</head>

<body>
    <div id="background"></div>
    <div id="tiles">
        <div id="tile-shadow" class="tile"></div>
    </div>
    <a class="icon" href="index.html"><img src="icon.svg" style="width: 200px;"></img></a>
    <!-- <h1 class="ui timer"><span id="time-min">0</span>:<span id="time-sec">00</span></h1> -->
    <!-- <h1 class="ui score">0</h1> -->
    <div class="notify-msg"><div></div><img src="alert.png" style="height: 20px;"></img><span>SeaMonkey21 just forced a draw!</span></div>
    <button class="submit-btn" onclick="tryDraw()"><img src="submit.png" style="height: 12px;"></img>draw</button>
    <img id="recenter-btn" src="recenter.png" onclick="recenterTiles()"></img>
    <h1 id="score">0</h1>
    <h1 id="timer"></h1>
    <!-- <div class="ui take-2" onclick="verifyTiles(tiles);">
        <div class="button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                    d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z">
                </path>
            </svg>
        </div>
    </div> -->
    <div id="overlay"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script>
        var target, target_initial_position, contested_tile_position, tile_is_contested, exiled_tile;

        var grid_pos = [0, 0];
        var tile_size = 45;
        var panning = false;
        var mouse_initial_position = [0, 0];
        var grid_initial_position = [0, 0];
        var score_pos = [window.innerWidth - 100, window.innerHeight - 100];

        var tiles = {};
        var tid = 0;
        var dict = [];

        var score = 0;
        var time = 100;
        const seconds = document.getElementById("time-sec");
        const minutes = document.getElementById("time-min");
        var score_allowed = true;

        const grid = document.getElementById("background");
        const tile_container = document.getElementById("tiles");
        const tile_shadow = document.getElementById("tile-shadow");

        var anchor_pos = [window.innerWidth / 2, window.innerHeight / 2];
        setGridPos(anchor_pos);

        const alphamap = {
            " ": { draws: 2, value: 0 },
            "A": { draws: 9, value: 1 },
            "B": { draws: 2, value: 3 },
            "C": { draws: 2, value: 3 },
            "D": { draws: 4, value: 2 },
            "E": { draws: 12, value: 1 },
            "F": { draws: 2, value: 4 },
            "G": { draws: 3, value: 2 },
            "H": { draws: 2, value: 4 },
            "I": { draws: 9, value: 1 },
            "J": { draws: 1, value: 8 },
            "K": { draws: 1, value: 5 },
            "L": { draws: 4, value: 1 },
            "M": { draws: 2, value: 3 },
            "N": { draws: 6, value: 1 },
            "O": { draws: 8, value: 1 },
            "P": { draws: 2, value: 3 },
            "Q": { draws: 1, value: 10 },
            "R": { draws: 6, value: 1 },
            "S": { draws: 4, value: 1 },
            "T": { draws: 6, value: 1 },
            "U": { draws: 4, value: 1 },
            "V": { draws: 2, value: 4 },
            "W": { draws: 2, value: 4 },
            "X": { draws: 1, value: 8 },
            "Y": { draws: 2, value: 4 },
            "Z": { draws: 1, value: 10 },
        }
        const alphaweightmap = [];
        Object.keys(alphamap).forEach(c => alphaweightmap.push(...new Array(alphamap[c].draws).fill(c)));

        fetch("wordlist.txt").then(response => response.text()).then((data) => dict = data.split("\r\n"));

        document.ontouchstart = (e) => {
            const touch = e.touches[0];
            if (touch) {
                if (touch.target.classList.contains("tile")) {
                    target = touch.target;
                    target_initial_position = tiles[target.getAttribute("tid")].position;
                    tile_shadow.style.opacity = 1;
                    target.style.zIndex = 3;

                    var tid = target.getAttribute("tid");
                    var mouse_pos = [touch.pageX, touch.pageY];
                    var snap_pos = resolveGridPos(mouse_pos);
                    tiles[tid].position = snap_pos;
                    tileTwerp(target, snap_pos, 0.1);
                    tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
                }
                else if (score_allowed) {
                    panning = true;
                    mouse_initial_position = [touch.pageX, touch.pageY];
                    grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
                }
            }
        }
        document.ontouchend = (e) => {
            const touch = e.changedTouches[0];
            if (target && touch) {
                var mouse_pos = [touch.pageX, touch.pageY];
                var snap_pos = snapToGrid(mouse_pos);
                var tid = target.getAttribute("tid");
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos);
                setTimeout(((jt) => target == jt ? null : jt.style.zIndex = 1).bind(null, target), 500);
                tile_shadow.style.opacity = 0;

                // var occupied_y = [];
                // for (const stile of Object.values(tiles)) {
                //     if (stile.position[0] == snap_pos[0]) occupied_y.push(stile.position[1]);
                // }
                // for (const stid of Object.keys(tiles)) {
                //     if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                //         if (occupied_y.length > 0) {
                //             for (var i = snap_pos[1] + tile_size, j = snap_pos[1] - tile_size, c = true; ; i += tile_size, j -= tile_size, c = !c) {
                //                 var new_y = c ? i : j;
                //                 if (!occupied_y.includes(new_y)) break;
                //             }
                //         }
                //         else var new_y = snap_pos[1] + tile_size;
                //         tiles[stid].position[1] = new_y;
                //         tileTwerp(tiles[stid].element, [snap_pos[0], new_y]);
                //     }
                // }

                for (const stid of Object.keys(tiles)) {
                    if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                        tiles[stid].position = target_initial_position;
                        tileTwerp(tiles[stid].element, target_initial_position);
                    }
                }
                onTilesUpdate();
            }

            target = null;
            if (panning = true) onPanningFinished();
            panning = false;

            contested_tile_position = [null, null];
            tile_is_contested = false;
        }
        document.ontouchmove = (e) => {
            const touch = e.touches[0];
            if (target && touch) {
                var tid = target.getAttribute("tid");
                var mouse_pos = [touch.pageX, touch.pageY];
                var snap_pos = resolveGridPos(mouse_pos);

                // if (tile_is_contested) {
                //     if (snap_pos[0] != contested_tile_position[0] || snap_pos[1] != contested_tile_position[1]) {
                //         exiled_tile.position = contested_tile_position;
                //         tileTwerp(exiled_tile.element, contested_tile_position);
                //         contested_tile_position = [null, null];
                //         tile_is_contested = false;
                //     }
                // }

                // for (const stid of Object.keys(tiles)) {
                //     if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                //         exiled_tile = tiles[stid];
                //         contested_tile_position = snap_pos;
                //         exiled_tile.position = target_initial_position;
                //         tileTwerp(exiled_tile.element, target_initial_position);
                //         tile_is_contested = true;
                //         break;
                //     };
                // }

                // target.style.top = snap_pos[1] + "px";
                // target.style.left = snap_pos[0] + "px";

                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos, 0.1);
                tileTwerp(tile_shadow, snapToGrid(mouse_pos));
            }
            else if (panning && score_allowed) {
                var mouse_pos = [touch.pageX, touch.pageY];
                setGridPos(grid_initial_position.map((c, i) => c + mouse_pos[i] - mouse_initial_position[i]));
            }
        }

        document.onmousedown = (e) => {
            if (e.button == 0 && e.target.classList) {
                if (e.target.classList.contains("tile")) {
                    target = e.target;
                    target_initial_position = tiles[target.getAttribute("tid")].position;
                    tile_shadow.style.opacity = 1;
                    target.style.zIndex = 3;

                    var tid = target.getAttribute("tid");
                    var mouse_pos = [e.pageX, e.pageY];
                    var snap_pos = resolveGridPos(mouse_pos);
                    tiles[tid].position = snap_pos;
                    tileTwerp(target, snap_pos, 0.1);
                    tileTwerp(tile_shadow, snapToGrid(mouse_pos), 0);
                }
                else if (score_allowed) {
                    panning = true;
                    mouse_initial_position = [e.pageX, e.pageY];
                    grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
                }
            }
        }
        document.onmouseup = (e) => {
            if (target) {
                var mouse_pos = [e.pageX, e.pageY];
                var snap_pos = snapToGrid(mouse_pos);
                var tid = target.getAttribute("tid");
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos);
                setTimeout(((jt) => target == jt ? null : jt.style.zIndex = 1).bind(null, target), 500);
                tile_shadow.style.opacity = 0;
                for (const stid of Object.keys(tiles)) {
                    if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                        tiles[stid].position = target_initial_position;
                        tileTwerp(tiles[stid].element, target_initial_position);
                    }
                }
                onTilesUpdate();
            }

            target = null;
            if (panning = true) onPanningFinished();
            panning = false;

            contested_tile_position = [null, null];
            tile_is_contested = false;
        }
        document.onmousemove = (e) => {
            if (target) {
                var tid = target.getAttribute("tid");
                var mouse_pos = [e.pageX, e.pageY];
                var snap_pos = resolveGridPos(mouse_pos);
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos, 0.1);
                tileTwerp(tile_shadow, snapToGrid(mouse_pos));
            }
            else if (panning && score_allowed) {
                var mouse_pos = [e.pageX, e.pageY];
                setGridPos(grid_initial_position.map((c, i) => c + mouse_pos[i] - mouse_initial_position[i]));
            }
        }

        function selectTileByTID(tid) {
            return document.body.querySelector(`div[tid="${tid}"]`);
        }

        function startTimer() {
            var time_whole = 100;
            var time_start = performance.now();
            updateTimer();
            var time_inter = setInterval(() => {
                time = Math.round(time_whole - (performance.now() - time_start) / 1000);
                if (time <= 0) {
                    endTimer();
                    clearInterval(time_inter);
                }
                updateTimer();
            }, 1);
        }

        function updateTimer() {
            if (score_allowed) {
                var min = Math.floor(time / 60);
                var sec = time % 60;
                minutes.innerHTML = min;
                seconds.innerHTML = sec.toString().length == 1 ? "0" + sec : sec;
            }
        }

        // function endTimer() {

        // }

        // function take2() {
        //     createTileRow(["A", "B"]);
        // }

        function tileTwerp(target, position, duration = 0.2) {
            gsap.to(target, {
                duration: duration,
                x: position[0] + "px",
                y: position[1] + "px",
                overwrite: "auto"
            });
            determineBorderRadii();
        }

        function tileAppear(target) {
            gsap.to(target, {
                duration: 0.2,
                scale: 1,
                overwrite: "auto"
            });
        }

        function setGridPos(position, duration = 0.2, ease = "power4.out") {
            gsap.to(grid, {
                duration,
                backgroundPosition: `${position[0]}px ${position[1]}px`,
                ease,
                overwrite: "auto"
            });
            gsap.to(tile_container, {
                duration,
                x: position[0] + "px",
                y: position[1] + "px",
                ease,
                overwrite: "auto"
            });
            grid_pos = position;
        }

        function snapToGrid(position, tile_relative = true) {
            return position.map((c, i) => (tile_relative ? 0 : grid_pos[i]) + Math.floor((c - grid_pos[i]) / tile_size) * tile_size);
        }

        function resolveGridPos(position, tile_relative = true) {
            return position.map((c, i) => c - (tile_relative ? grid_pos[i] : 0) - tile_size / 2);
        }

        function cloneElement(tile, delay, color = "var(--light-green)", wild = false) {
            setTimeout(() => {
                var copy = tile.element.cloneNode(true);
                copy.setAttribute("tid", "-1");
                copy.style.borderRadius = tile_size / 5 + "px";
                copy.style.backgroundColor = color;
                copy.style.boxShadow = "0 0 5px #00000033";
                document.body.appendChild(copy);
                gsap.set(copy, {
                    x: tile.position[0] + grid_pos[0],
                    y: tile.position[1] + grid_pos[1],
                });
                gsap.to(copy, {
                    duration: 0.5,
                    y: tile.position[1] + grid_pos[1] - tile_size / 2 + Math.random() * 5,
                    ease: "power4.out"
                });
                var score_ui_rect = document.getElementById("score").getBoundingClientRect();
                gsap.to(copy, {
                    duration: 1,
                    delay: 0.5,
                    x: score_ui_rect.left + score_ui_rect.width / 2 - tile_size / 2 + "px",
                    y: score_ui_rect.top - tile_size / 2 + 10 + "px",
                    ease: "power4.out"
                });
                gsap.to(copy, {
                    duration: 0.5,
                    delay: 1.0,
                    scale: 0
                });
                setTimeout(() => document.body.removeChild(copy), 2000);
            }, delay);
        }

        function scoreTiles(tiles) {
            if (score_allowed) {
                score_allowed = false;
                var words = getWordMap(tiles);
                var score = 0;
                var delay = 0;
                for (var i = 0; i < words.length; i++) {
                    var s = (words[i].valid ? 1 : -1) * getWordScore(words[i].word);
                    score += s;
                    for (var j = 0; j < words[i].tiles.length; j++) {
                        const tile = words[i].tiles[j];
                        cloneElement(tile, delay, words[i].valid ? "var(--light-green)" : (words[i].disconnected ? "var(--light-yellow)" : "var(--light-red)"));
                        delay += 50;
                    }
                }
                var score_ui = document.querySelector(".ui.score");
                var bonus = score > score_ui.innerText;
                for (var i = 0; i < Math.abs(score - score_ui.innerText); i++) setTimeout(() => score_ui.innerText = parseInt(score_ui.innerText) + (bonus ? 1 : -1), delay + 1000 + i * 10);
                setTimeout(() => {
                    take2();
                    score_allowed = true;
                }, delay + 500);
            }
        }

        function createTile(letter, value, position, delay = 0) {
            const stid = JSON.parse(JSON.stringify(tid));
            tid++;
            var tile_element = document.createElement("div");
            tile_element.classList.add("tile");
            tile_element.setAttribute("tid", stid);
            tile_element.setAttribute("letter", letter);
            tile_element.innerHTML = letter;
            var value_element = document.createElement("span");
            value_element.classList.add("value");
            value_element.innerHTML = value;
            tile_element.appendChild(value_element);
            tile_container.appendChild(tile_element);
            tiles[stid] = { position, element: tile_element, tid: stid, letter };
            tileTwerp(tile_element, position, 0);
            gsap.set(tile_element, { scale: 0 });
            setTimeout(() => tileAppear(tile_element), delay);
            onTilesUpdate();
            return stid;
        }

        function determineBorderRadii() {
            for (var tile of Object.values(tiles)) {
                // top-left, top-right, bottom-right, bottom-left
                var el = tile.element;
                var radius = tile_size / 5;
                var vert = [false, false];
                var horiz = [false, false];
                for (var stile of Object.values(tiles)) {
                    if (stile.tid != tile.tid) {
                        if (stile.position[1] == tile.position[1]) {
                            if (stile.position[0] == tile.position[0] + tile_size) horiz[1] = true;
                            else if (stile.position[0] == tile.position[0] - tile_size) horiz[0] = true;
                        }
                        else if (stile.position[0] == tile.position[0]) {
                            if (stile.position[1] == tile.position[1] + tile_size) vert[1] = true;
                            else if (stile.position[1] == tile.position[1] - tile_size) vert[0] = true;
                        }
                    }
                }
                var borders = [vert[0] || horiz[0], vert[0] || horiz[1], vert[1] || horiz[1], vert[1] || horiz[0]];
                el.style.borderRadius = `${borders[0] ? 0 : radius}px ${borders[1] ? 0 : radius}px ${borders[2] ? 0 : radius}px ${borders[3] ? 0 : radius}px`;
            }
        }

        function pickRandomTile() {
            return alphaweightmap[Math.round(Math.random() * (alphaweightmap.length - 1))];
        }

        function createTileRow(letters, twerp = true) {
            const size = letters.length;
            var pos = [-Math.round(size/2)*tile_size, 0];
            if (Object.keys(tiles).length > 0) {
                var vertex_tile = Math.max.apply(null, Object.keys(tiles).map((tile) => tiles[tile].position[1]));
                pos[1] = vertex_tile + tile_size * 2;
            }
            for (var i = 0; i < size; i++) {
                createTile(letters[i], alphamap[letters[i]].value, JSON.parse(JSON.stringify(pos)), i*100);
                pos[0] += tile_size;
            }
            if (twerp) setGridPos([anchor_pos[0] + tile_size * (size % 2) * 0.5, -pos[1] + anchor_pos[1]], 0.5, "power4.out");
        }

        function getAllWords(tiles) {
            var axes = [{}, {}];
            for (var [i, tile] of Object.entries(tiles)) {
                for (var j = 0; j < 2; j++) {
                    if (!axes[j].hasOwnProperty(tile.position[j])) axes[j][tile.position[j]] = [];
                    axes[j][tile.position[j]].push(tile);
                }
            }

            var tile_groups = [];
            for (var j = 0; j < 2; j++) {
                for (var [k, unsorted] of Object.entries(axes[j])) {
                    var consecutive = [];
                    var prev = null;
                    var sorted = unsorted.sort((a, b) => a.position[1 - j] - b.position[1 - j]);
                    for (var tile of sorted) {
                        var axis = tile.position[1 - j] / tile_size;
                        if (Math.abs(axis - prev) <= 1 || prev == null) consecutive.push(tile);
                        else {
                            if (consecutive.length > 1) tile_groups.push(consecutive);
                            consecutive = [tile];
                            prev = null;
                        }
                        prev = axis;
                    }
                    if (consecutive.length > 1) tile_groups.push(consecutive);
                }
            }

            var words = [];
            for (var group of tile_groups) words.push({ word: group.map((c) => c.letter).join(""), tiles: group });
            return words;
        }

        function recenterTiles() {
            var far_left, far_top, far_right, far_bottom;
            for (var [i, tile] of Object.entries(tiles)) {
                if (tile.position[0] < far_left || far_left == null) far_left = tile.position[0];
                if (tile.position[0] > far_right || far_right == null) far_right = tile.position[0];
                if (tile.position[1] < far_top || far_top == null) far_top = tile.position[1];
                if (tile.position[1] > far_bottom || far_bottom == null) far_bottom = tile.position[1];
            }
            const center = [(far_right + far_left)/2, (far_bottom + far_top)/2];
            setGridPos([anchor_pos[0] - center[0], anchor_pos[1] - center[1]], 0.5, "power4.out");
            onPanningFinished();
        }

        function tileInScreen(tile) {
            const adjusted_pos = [grid_pos[0] + tile.position[0], grid_pos[1] + tile.position[1]];
            return !(adjusted_pos[0] < 0 || adjusted_pos[0] > window.innerWidth || adjusted_pos[1] < 0 || adjusted_pos[1] > window.innerHeight);
        }

        function findWildWords(word) {
            var possible_words = [];
            for (var dict_word of dict) {
                if (dict_word.length == word.length) {
                    var break_flag = false;
                    for (var i = 0; i < dict_word.length; i++) {
                        if (word[i] != " " && word[i] != dict_word[i]) {
                            break_flag = true;
                            break;
                        }
                    }
                    if (!break_flag) possible_words.push(dict_word);
                }
            }
            return possible_words;
        }

        function checkValidWords(words) {
            var word_map = words;
            for (var group of word_map) {
                if (!group.word.includes(" ")) group.valid = dict.includes(group.word);
            }

            var wild_tiles = {};
            for (var group of word_map) {
                if (group.word.includes(" ")) {
                    for (var tile of group.tiles) {
                        if (tile.letter == " ") {
                            if (wild_tiles.hasOwnProperty(tile.tid)) wild_tiles[tile.tid].push(group);
                            else wild_tiles[tile.tid] = [group];
                        }
                    }
                }
            }
            for (var tid of Object.keys(wild_tiles)) {
                var word_options = [];
                var stop_flag = false;

                for (var group of wild_tiles[tid]) {
                    var possibilities = findWildWords(group.word);
                    if (possibilities.length > 0) {
                        var wild_indices = group.word.split("").map((c, i) => i).filter((c) => group.word[c] == " ");
                        var this_wild_index = group.tiles.map((c, i) => c = { i, tid: c.tid }).filter((c) => c.tid == tid)[0].i;
                        word_options.push({ possibilities, index: this_wild_index });
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                        stop_flag = true;
                    }
                }

                if (!stop_flag) {
                    var possible_substitutions = [];
                    for (var option of word_options) {
                        var possible_substitution = option.possibilities.map((c) => c[option.index]);
                        possible_substitutions.push(possible_substitution);
                    }

                    var valid = possible_substitutions.slice(1).every(array => array.some(el => possible_substitutions[0].includes(el)));
                    if (valid) {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0 && !group.hasOwnProperty("valid")) group.valid = true;
                        }
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                    }
                }
            }

            return word_map;
        }

        function getSingles(words) {
            var word_ids = words.flatMap((c) => c.tiles.map((d) => d.tid));
            var all_ids = Object.keys(tiles).map((c) => tiles[c].tid);
            var single_ids = all_ids.filter((c) => !word_ids.includes(c));
            var singles = single_ids.map((c) => tiles[c]);
            return singles;
        }

        // function getScore(tiles) {
        //     var score = 0;
        //     var words = getWordMap(tiles);
        //     for (var group of words) score += (group.valid ? 1 : 0)*group.word.split("").reduce((psum, c) => psum + alphamap[c].value, 0);
        //     return score;
        // }

        function getWordScore(word) {
            return word.split("").reduce((psum, c) => psum + alphamap[c].value, 0)
        }

        function getScore(words) {
            var score = 0;
            for (var group of words) score += (group.valid ? 1 : 0) * getWordScore(group.word);
            return score;
        }

        function calculateScore(word) {
            var score = 0;
            for (var letter of word) score += alphamap[letter].value;
            return score;
        }

        function getConsecutiveTileGroups(tiles) {
            var visited = new Set();
            var groups = [];

            function getAdjacents(tile) {
                var adjacents = [];
                for (var stile of Object.values(tiles)) {
                    if (stile.tid != tile.tid) {
                        var x_diff = Math.abs(stile.position[0] - tile.position[0]);
                        var y_diff = Math.abs(stile.position[1] - tile.position[1]);
                        if ((x_diff <= tile_size && y_diff <= tile_size) && (x_diff == 0 || y_diff == 0) && !(x_diff == 0 && y_diff == 0)) {
                            adjacents.push(stile);
                        }
                    }
                }
                return adjacents;
            }

            function firstSearch(tile, group) {
                visited.add(tile.tid);
                group.push(tile);
                var adjacents = getAdjacents(tile);
                if (adjacents.length > 0) {
                    for (var adjacent of adjacents) {
                        if (!visited.has(adjacent.tid)) {
                            firstSearch(adjacent, group);
                        }
                    }
                }
                else groups.push([tile]);
            }

            for (var tile of Object.values(tiles)) {
                if (!visited.has(tile.id)) {
                    var group = [];
                    firstSearch(tile, group);
                    if (group.length > 1) groups.push(group);
                }
            }

            return groups;
        }

        function calculateConnectionPenalties(words) {
            var word_map = words;
            var groups = getConsecutiveTileGroups(tiles);
            var scores = groups.map((c) => getScore(checkValidWords(getAllWords(c))));
            var penalized_groups = groups.filter((c, i) => i != scores.indexOf(Math.max(...scores)));
            var penalized_tile_tids = penalized_groups.flat().map((c) => c.tid);
            var singles = penalized_groups.filter((c) => c.length == 1);
            for (var group of word_map) {
                for (var tile of group.tiles) {
                    if (penalized_tile_tids.includes(tile.tid)) {
                        if (group.valid) group.disconnected = true;
                        group.valid = false;
                    }
                }
            }
            for (var tile of singles) word_map.push({ word: tile[0].letter, tiles: [tile[0]], valid: false });
            return word_map;
        }

        function getWordMap(tiles) {
            var words = getAllWords(tiles);
            words = checkValidWords(words);
            words = calculateConnectionPenalties(words);
            return words;
        }
        //createTileRow(2);
    </script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script>
        const config = {
            apiKey: "AIzaSyCYiF56kcc8XriibM-KGFcGfhfYYtvyQ1s",
            authDomain: "vocabulum-220c3.firebaseapp.com",
            projectId: "vocabulum-220c3",
            storageBucket: "vocabulum-220c3.firebasestorage.app",
            messagingSenderId: "143266091587",
            appId: "1:143266091587:web:aa07a256380819be63faf6",
            measurementId: "G-5SFXW24TDN"
        }
        const app = firebase.initializeApp(config);
        const database = firebase.database();
        const ref = (r) => firebase.database().ref(r);

        const params = new URLSearchParams(window.location.href.split("?")[1]);
        const my_id = params.get("id");
        const my_type = params.get("t");
        const my_name = params.get("n");
        const my_lobby = params.get("l");

        const my_lobby_path = "lobbies/" + my_lobby + "/";
        const my_lobby_data_path = my_lobby_path + "data/";
        const my_mem_path = my_lobby_path + "members/" + my_id + "/";
        const my_data_path = my_mem_path + "data/";

        const idraw = (deck) => deck.splice(Math.floor(Math.random()*deck.length), 1)[0];
        const ndraw = (deck, n) => Array(n).fill(0).map((x) => x = idraw(deck));
        const nrep = (arr, n) => Array(n).fill(arr).flat();
        
        var draw_timeout;
        var draw_start_date;
        var alert_close_timeout;

        const auto_draw_delay = 61*1000;

        function onPanningFinished() {
            const recenter_btn = document.getElementById("recenter-btn");
            var tiles_hidden = true;
            for (const [i, tile] of Object.entries(tiles)) {
                if (tileInScreen(tile)) {
                    tiles_hidden = false;
                    break;
                }
            }
            if (tiles_hidden) recenter_btn.classList.add("active");
            else recenter_btn.classList.remove("active");
        }

        function triggerAlert(content) {
            document.querySelector(".notify-msg").classList.remove("active");
            if (alert_close_timeout) {
                clearTimeout(alert_close_timeout);
                alert_close_timeout = null;
            }
            setTimeout(() => {
                document.querySelector(".notify-msg span").innerText = content;
                document.querySelector(".notify-msg").classList.add("active");
                alert_close_timeout = setTimeout(() => document.querySelector(".notify-msg").classList.remove("active"), 3000);
            }, 100);
        }

        function tryDraw() {
            if (score_allowed) {
                score_allowed = false;
                var words = getWordMap(tiles);
                var delay = 0;
                var all_valid = true;
                for (var i = 0; i < words.length; i++) {
                    if (!words[i].valid) all_valid = false;
                    for (var j = 0; j < words[i].tiles.length; j++) {
                        const tile = words[i].tiles[j];
                        cloneElement(tile, delay, words[i].valid ? "var(--light-green)" : (words[i].disconnected ? "var(--light-yellow)" : "var(--light-red)"));
                        delay += 50;
                    }
                }
                setTimeout(() => {
                    if (all_valid) assignDraws(2);
                    else triggerAlert("need to finish deck before you draw!");
                    score_allowed = true;
                }, delay + 500);
            }
        }

        var deck = [...alphaweightmap];
        function assignDraws(n, init = false, auto = false) {
            ref(my_lobby_path + "members").once("value").then((snapshot) => {
                const members = snapshot.val();
                const mem_count = Object.keys(members).length;
                if (init) deck = nrep(alphaweightmap, Math.ceil(mem_count*(mem_count <= 4 ? 21 : mem_count <= 6 ? 15 : 11)/alphaweightmap.length));
                ref(my_lobby_data_path + "deck").once("value").then((snapshot) => {
                    if (snapshot.exists()) deck = snapshot.val().split("");
                    ref(my_lobby_data_path + "drawer").set(init ? "initial" : (auto ? "auto" : my_name));
                    for (const mid of Object.keys(members)) {
                        const mem = members[mid];
                        const draw = ndraw(deck, n).join("");
                        ref(my_lobby_path + "members/" + mid + "/data/draw").set(draw);
                        ref(my_lobby_path + "members/" + mid + "/data/draw_history").push(draw);
                    }
                    ref(my_lobby_data_path + "last_draw_date").set(new Date().toISOString());
                    ref(my_lobby_data_path + "deck").set(deck.join(""));
                })
            });
        }

        function restoreTilesFromBlob(blob) {
            for (const blob_tile of blob) {
                const position = [blob_tile.position.x, blob_tile.position.y];
                const letter = blob_tile.letter;
                createTile(letter, alphamap[letter].value, position);
            }
            recenterTiles();
            triggerAlert("connection restored!");
        }

        function blobifyTiles() {
            const blob = [];
            for (const key of Object.keys(tiles)) {
                const tile = tiles[key];
                blob.push({
                    position: {
                        x: tiles[key].position[0],
                        y: tiles[key].position[1]
                    },
                    letter: tiles[key].letter
                });
            }
            return blob;
        }

        function onTilesUpdate() {
            ref(my_lobby_path + "members/" + my_id + "/data/tiles").set(blobifyTiles());
        }

        // restore connection
        ref(my_lobby_path + "members/" + my_id + "/data/tiles").once("value").then((snapshot) => {
            if (snapshot.exists()) {
                restoreTilesFromBlob(snapshot.val());
                ref(my_data_path + "draws_received").once("value").then((snapshot) => {
                    if (snapshot.exists()) {
                        const draws_received = snapshot.val();
                        ref(my_data_path + "draw_history").once("value").then((snapshot) => {
                            if (snapshot.exists()) {
                                const draw_history = Object.values(snapshot.val());
                                const intended_draws_received = draw_history.length;
                                if (draws_received < intended_draws_received) {
                                    const draws_to_add = draw_history.slice(draws_received);
                                    for (const draw of draws_to_add) createTileRow(draw.split(""), false);
                                    ref(my_data_path + "draws_received").set(intended_draws_received);
                                    recenterTiles();
                                }
                            }
                        });
                    }
                });
            }
            else if (my_type == "host" || my_id == "0") assignDraws(7, true);
        });

        function onRefUpdate(r, callback = () => {}) {
            var ct = 0;
            const l = r.on("value", (snapshot) => {
                if (ct++ == 1) {
                    r.off("value", l);
                    callback(snapshot);
                }
            });
        }

        function setTimer(delay = auto_draw_delay) {
            if (draw_timeout) clearTimeout(draw_timeout);
            draw_timeout = setTimeout(() => {
                assignDraws(2, false, true);
                setTimer();
            }, delay);
            draw_start_date = new Date(new Date().getTime() - (auto_draw_delay - delay));
        }

        // on someone draws
        var ct = 0;
        ref(my_data_path + "draw").on("value", (snapshot) => {
            if (ct++ > 0) {
                const letters = snapshot.val().split("");
                ref(my_lobby_data_path + "drawer").once("value").then((snapshot) => {
                    const drawer = snapshot.val();
                    var twerp = true;
                    if (drawer) {
                        if (drawer != "initial" && drawer != my_name && drawer != "auto") {
                            triggerAlert(drawer + " just forced a draw!");
                            twerp = false;
                        }
                        else if (drawer == "auto") {
                            triggerAlert("everyone given help!");
                            twerp = false;
                        }
                    }
                    if (my_type == "host") setTimer();
                    createTileRow(letters, twerp);
                    ref(my_data_path + "draws_received").transaction((post) => {
                        if (post) return post + 1;
                        else return 1;
                    });
                });
            }
        });

        // on draw date update
        var cdt = 0;
        ref(my_lobby_data_path + "last_draw_date").on("value", (snapshot) => {
            if (snapshot.exists()) {
                if (cdt++ == 0 && my_type == "host") {
                    const time_difference = new Date() - new Date(snapshot.val());
                    if (time_difference >= auto_draw_delay) {
                        assignDraws(2, false, true);
                        setTimer();
                    }
                    else setTimer(auto_draw_delay - time_difference);
                }
                else draw_start_date = new Date(snapshot.val());
            }
        });

        setInterval(() => {
            const seconds_until_draw = (auto_draw_delay - (new Date() - draw_start_date))/1000;
            const mins = Math.floor(seconds_until_draw / 60);
            const secs = Math.floor(seconds_until_draw % 60);
            const text = mins + ":" + (secs < 10 ? "0" : "") + secs;
            document.getElementById("timer").innerHTML = text.split("").map((l) => `<span>${l}</span>`).join("");
        }, 100);
    </script>
</body>

</html>