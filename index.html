<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&display=swap" rel="stylesheet">
    <title>Vocabulum</title>
    <style>
        :root {
            --bg-grid-color: #00000017;
            --tile-size: 40px;
            --tile-color: #f9be74ff;
        }

        body {
            margin: 0;
            user-select: none;
            overflow: hidden;
        }

        #background {
            width: 100vw;
            height: 100vh;
            margin: 0;
            background-size: var(--tile-size) var(--tile-size);
            background-image: linear-gradient(to right, var(--bg-grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--bg-grid-color) 1px, transparent 1px);
            background-position: 0 0;
        }

        .tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            background-color: var(--tile-color);
            border-radius: calc(var(--tile-size)/5);
            text-align: center;
            line-height: calc(var(--tile-size) + var(--tile-size)/12);
            font-size: calc(var(--tile-size)/1.7);
            font-family: 'Comfortaa', sans-serif;
            font-weight: bold;
            cursor: pointer;
            top: 0;
            left: 0;
            /* transition: transform 0.2s, top 0.1s, left 0.1s; */
        }

        .tile:active {
            /* transform: scale(0.85); */
        }

        .tile>.value {
            position: absolute;
            left: calc(var(--tile-size)/7);
            top: calc(var(--tile-size)/7);
            line-height: calc(var(--tile-size)/4);
            font-size: calc(var(--tile-size)/4);
            pointer-events: none;
        }

        #tiles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <div id="background"></div>
    <div id="tiles"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script>
        var target, target_initial_position, contested_tile_position, tile_is_contested, exiled_tile;

        var grid_pos = [0, 0];
        var tile_size = 40;
        var panning = false;
        var mouse_initial_position = [0, 0];
        var grid_initial_position = [0, 0];

        var tiles = {};
        var tid = 0;
        var dict = [];

        const grid = document.getElementById("background");
        const tile_container = document.getElementById("tiles");

        var anchor_pos = snapToGrid([window.innerWidth/2, window.innerHeight/2], false);

        const alphamap = {
            " ": { draws: 2, value: 0 },
            "A": { draws: 9, value: 1 },
            "B": { draws: 2, value: 3 },
            "C": { draws: 2, value: 3 },
            "D": { draws: 4, value: 2 },
            "E": { draws: 12, value: 1 },
            "F": { draws: 2, value: 4 },
            "G": { draws: 3, value: 2 },
            "H": { draws: 2, value: 4 },
            "I": { draws: 9, value: 1 },
            "J": { draws: 1, value: 8 },
            "K": { draws: 1, value: 5 },
            "L": { draws: 4, value: 1 },
            "M": { draws: 2, value: 3 },
            "N": { draws: 6, value: 1 },
            "O": { draws: 8, value: 1 },
            "P": { draws: 2, value: 3 },
            "Q": { draws: 1, value: 10 },
            "R": { draws: 6, value: 1 },
            "S": { draws: 4, value: 1 },
            "T": { draws: 6, value: 1 },
            "U": { draws: 4, value: 1 },
            "V": { draws: 2, value: 4 },
            "W": { draws: 2, value: 4 },
            "X": { draws: 1, value: 8 },
            "Y": { draws: 2, value: 4 },
            "Z": { draws: 1, value: 10 },
        }
        const alphaweightmap = [];
        Object.keys(alphamap).forEach(c => alphaweightmap.push(...new Array(alphamap[c].draws).fill(c)));

        fetch("wordlist.txt").then(response => response.text()).then((data) => dict = data.split("\r\n"));

        document.onmousedown = (e) => {
            if (e.button == 0 && e.target.classList) {
                if (e.target.classList.contains("tile")) {
                    target = e.target;
                    target_initial_position = tiles[target.getAttribute("tid")].position;
                }
                else {
                    panning = true;
                    mouse_initial_position = [e.pageX, e.pageY];
                    grid_initial_position = JSON.parse(JSON.stringify(grid_pos));
                }
            }
        }
        document.onmouseup = (e) => {
            target = null;
            panning = false;

            contested_tile_position = [null, null];
            tile_is_contested = false;
        }
        document.onmousemove = (e) => {
            if (target) {
                var tid = target.getAttribute("tid");
                var mouse_pos = [e.pageX, e.pageY];
                var snap_pos = snapToGrid(mouse_pos);

                if (tile_is_contested) {
                    if (snap_pos[0] != contested_tile_position[0] || snap_pos[1] != contested_tile_position[1]) {
                        exiled_tile.position = contested_tile_position;
                        tileTwerp(exiled_tile.element, contested_tile_position);
                        contested_tile_position = [null, null];
                        tile_is_contested = false;
                    }
                }

                for (const stid of Object.keys(tiles)) {
                    if (tiles[stid].position[0] == snap_pos[0] && tiles[stid].position[1] == snap_pos[1] && tid != stid) {
                        exiled_tile = tiles[stid];
                        contested_tile_position = snap_pos;
                        exiled_tile.position = target_initial_position;
                        tileTwerp(exiled_tile.element, target_initial_position);
                        tile_is_contested = true;
                        break;
                    };
                }

                // target.style.top = snap_pos[1] + "px";
                // target.style.left = snap_pos[0] + "px";
                
                tiles[tid].position = snap_pos;
                tileTwerp(target, snap_pos);
            }
            else if (panning) {
                var mouse_pos = [e.pageX, e.pageY];
                setGridPos(grid_initial_position.map((c, i) => c + mouse_pos[i] - mouse_initial_position[i]));
            }
        }

        function selectTileByTID(tid) {
            return document.body.querySelector(`div[tid="${tid}"]`);
        }

        function tileTwerp(target, position, duration = 0.2) {
            gsap.to(target, {
                duration: duration,
                x: position[0] + "px",
                y: position[1] + "px",
                overwrite: "auto"
            });
        }

        function tileAppear(target) {
            gsap.to(target, {
                duration: 0.2,
                scale: 1,
                overwrite: "auto"
            });
        }

        function setGridPos(position, duration = 0.2, ease = "power4.out") {
            gsap.to(grid, {
                duration,
                backgroundPosition: `${position[0]}px ${position[1]}px`,
                ease,
                overwrite: "auto"
            });
            gsap.to(tile_container, {
                duration,
                x: position[0] + "px",
                y: position[1] + "px",
                ease,
                overwrite: "auto"
            });
            grid_pos = position;
        }

        function snapToGrid(position, tile_relative = true) {
            return position.map((c, i) => (tile_relative ? 0 : grid_pos[i]) + Math.floor((c - grid_pos[i])/tile_size)*tile_size);
        }

        function createTile(letter, value, position, delay = 0) {
            const stid = JSON.parse(JSON.stringify(tid));
            tid++;
            var tile_element = document.createElement("div");
            tile_element.classList.add("tile");
            tile_element.setAttribute("tid", stid);
            tile_element.setAttribute("letter", letter);
            tile_element.innerHTML = letter;
            var value_element = document.createElement("span");
            value_element.classList.add("value");
            value_element.innerHTML = value;
            tile_element.appendChild(value_element);
            tile_container.appendChild(tile_element);
            tiles[stid] = { position, element: tile_element, tid: stid, letter };
            tileTwerp(tile_element, position, 0);
            gsap.set(tile_element, { scale: 0 });
            setTimeout(() => tileAppear(tile_element), delay);
            return stid;
        }

        function pickRandomTile() {
            return alphaweightmap[Math.round(Math.random() * (alphaweightmap.length - 1))];
        }

        function createTileRow(size) {
            var pos = [anchor_pos[0] - Math.round(size/2)*tile_size, anchor_pos[1]];
            if (Object.keys(tiles).length > 0) {
                var vertex_tile = Math.max.apply(null, Object.keys(tiles).map((tile) => tiles[tile].position[1]));
                pos[1] = vertex_tile + tile_size*2;
            }
            for (var i = 0; i < size; i++) {
                var random_tile = pickRandomTile();
                createTile(random_tile, alphamap[random_tile].value, JSON.parse(JSON.stringify(pos)), i*100);
                pos[0] += tile_size;
            }
            setGridPos([0, -pos[1] + anchor_pos[1]], 0.5, "power4.out");
        }

        function getAllWords(tiles) {
            var axes = [{}, {}];
            for (var [i, tile] of Object.entries(tiles)) {
                for (var j = 0; j < 2; j++) {
                    if (!axes[j].hasOwnProperty(tile.position[j])) axes[j][tile.position[j]] = [];
                    axes[j][tile.position[j]].push(tile);
                }
            }

            var tile_groups = [];
            for (var j = 0; j < 2; j++) {
                for (var [k, unsorted] of Object.entries(axes[j])) {
                    var consecutive = [];
                    var prev = null;
                    var sorted = unsorted.sort((a, b) => a.position[1 - j] - b.position[1 - j]);
                    for (var tile of sorted) {
                        var axis = tile.position[1 - j]/tile_size;
                        if (Math.abs(axis - prev) <= 1 || prev == null) consecutive.push(tile);
                        else {
                            if (consecutive.length > 1) tile_groups.push(consecutive);
                            consecutive = [tile];
                            prev = null;
                        }
                        prev = axis;
                    }
                    if (consecutive.length > 1) tile_groups.push(consecutive);
                }
            }

            var words = [];
            for (var group of tile_groups) words.push({ word: group.map((c) => c.letter).join(""), tiles: group });
            return words;
        }

        function findWildWords(word) {
            var possible_words = [];
            for (var dict_word of dict) {
                if (dict_word.length == word.length) {
                    var break_flag = false;
                    for (var i = 0; i < dict_word.length; i++) {
                        if (word[i] != " " && word[i] != dict_word[i]) {
                            break_flag = true;
                            break;
                        }
                    }
                    if (!break_flag) possible_words.push(dict_word);
                }
            }
            return possible_words;
        }

        function checkValidWords(words) {
            var word_map = words;
            for (var group of word_map) {
                if (!group.word.includes(" ")) group.valid = dict.includes(group.word);
            }
            
            var wild_tiles = {};
            for (var group of word_map) {
                if (group.word.includes(" ")) {
                    for (var tile of group.tiles) {
                        if (tile.letter == " ") {
                            if (wild_tiles.hasOwnProperty(tile.tid)) wild_tiles[tile.tid].push(group);
                            else wild_tiles[tile.tid] = [group];
                        }
                    }
                }
            }
            for (var tid of Object.keys(wild_tiles)) {
                var word_options = [];
                var stop_flag = false;

                for (var group of wild_tiles[tid]) {
                    var possibilities = findWildWords(group.word);
                    if (possibilities.length > 0) {
                        var wild_indices = group.word.split("").map((c, i) => i).filter((c) => group.word[c] == " ");
                        var this_wild_index = group.tiles.map((c, i) => c = { i, tid: c.tid }).filter((c) => c.tid == tid)[0].i;
                        word_options.push({ possibilities, index: this_wild_index });
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                        stop_flag = true;
                    }
                }

                if (!stop_flag) {
                    var possible_substitutions = [];
                    for (var option of word_options) {
                        var possible_substitution = option.possibilities.map((c) => c[option.index]);
                        possible_substitutions.push(possible_substitution);
                    }

                    var valid = possible_substitutions.slice(1).every(array => array.some(el => possible_substitutions[0].includes(el)));
                    if (valid) {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0 && !group.hasOwnProperty("valid")) group.valid = true;
                        }
                    }
                    else {
                        for (var group of word_map) {
                            if (group.tiles.filter((c) => c.tid == tid).length > 0) group.valid = false;
                        }
                    }
                }
            }
            
            return word_map;
        }

        function getSingles(words) {
            var word_ids = words.flatMap((c) => c.tiles.map((d) => d.tid));
            var all_ids = Object.keys(tiles).map((c) => tiles[c].tid);
            var single_ids = all_ids.filter((c) => !word_ids.includes(c));
            var singles = single_ids.map((c) => tiles[c]);
            return singles;
        }

        function getScore(tiles) {
            var words = getAllWords(tiles);
            words = checkValidWords(words);
            words = calculateConnectionPenalties(words);
            console.log(words);

            var score = 0;
            for (var group of words) score += (group.valid ? 1 : 0)*group.word.split("").reduce((psum, c) => psum + alphamap[c].value, 0);
            return score;
        }

        function calculateScore(word) {
            var score = 0;
            for (var letter of word) score += alphamap[letter].value;
            return score;
        }

        function getConsecutiveTileGroups(tiles) {
            var visited = new Set();
            var groups = [];

            function getAdjacents(tile) {
                var adjacents = [];
                for (var stile of Object.values(tiles)) {
                    if (stile.tid != tile.tid) {
                        var x_diff = Math.abs(stile.position[0] - tile.position[0]);
                        var y_diff = Math.abs(stile.position[1] - tile.position[1]);
                        if ((x_diff <= tile_size && y_diff <= tile_size) && (x_diff == 0 || y_diff == 0) && !(x_diff == 0 && y_diff == 0)) {
                            adjacents.push(stile);
                        }
                    }
                }
                return adjacents;
            }

            function firstSearch(tile, group) {
                visited.add(tile.tid);
                group.push(tile);
                var adjacents = getAdjacents(tile);
                if (adjacents.length > 0) {
                    for (var adjacent of adjacents) {
                        if (!visited.has(adjacent.tid)) {
                            firstSearch(adjacent, group);
                        }
                    }
                }
                else groups.push([tile]);
            }

            for (var tile of Object.values(tiles)) {
                if (!visited.has(tile.id)) {
                    var group = [];
                    firstSearch(tile, group);
                    if (group.length > 1) groups.push(group);
                }
            }

            return groups;
        }

        function calculateConnectionPenalties(words) {
            var word_map = words;
            var groups = getConsecutiveTileGroups(tiles);
            var penalized_groups = groups.filter((_, i, arr) => i != arr.indexOf(arr.reduce((a, b) => b.length > a.length ? b : a)));
            var penalized_tile_tids = penalized_groups.flat().map((c) => c.tid);
            var singles = penalized_groups.filter((c) => c.length == 1);
            for (var group of word_map) {
                for (var tile of group.tiles) {
                    if (penalized_tile_tids.includes(tile.tid)) group.valid = false;
                }
            }
            for (var tile of singles) word_map.push({ word: tile[0].letter, tiles: [tile[0]], valid: false });
            return words;
        }

        createTileRow(7);
        //createTileRow(2);
        getScore(tiles);
    </script>
</body>

</html>